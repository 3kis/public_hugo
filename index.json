[{"content":"文件分享 指定项目的目录为文件上传目录\n1 2 //System.getProperty(\u0026#34;user.dir\u0026#34;)会得到当前项目的根目录 public final String FILE_UPLOAD_DIR = System.getProperty(\u0026#34;user.dir\u0026#34;) + \u0026#34;/images/\u0026#34;; 接口参数设计：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 @PostMapping(\u0026#34;/photo\u0026#34;) public Result savePhoto(HttpServletRequest httpServletRequest, @RequestParam(\u0026#34;image\u0026#34;) MultipartFile image) throws BaseException { //获取原始文件名称，目的是为了获取到原始文件的后缀 String originalFilename = image.getOriginalFilename(); //获取文件的后缀名 String fileSuffix = originalFilename.substring(originalFilename.lastIndexOf(\u0026#34;.\u0026#34;)); //通过uuid来生成唯一的文件名前缀存储在服务器 UUID uuid = UUID.randomUUID(); //拼接uuid的字符串和文件后缀名作为新的文件名 String newFilename = uuid.toString() + fileSuffix; //创建我们所需要的存储文件的目录 File fileDirectory = new File(FILE_UPLOAD_DIR); //destFile代表上传文件在服务器端保存的目标文件。形参的image变量只是存在了内存中 File destFile = new File(FILE_UPLOAD_DIR + newFilename); //判断目录是否存在 if (!fileDirectory.exists()) { //如果不存在，则创建目录，如果创建失败了，那么抛出异常 if (!fileDirectory.mkdir()) { throw new BaseException(ExceptionEnum.MKDIR_FAILED); } } //将image转存到目标文件 try { image.transferTo(destFile); } catch (IOException e) { e.printStackTrace() ; } try { return Result .success(getHost(new URI(httpServletRequest.getRequestURL() + \u0026#34;\u0026#34;)) + \u0026#34;/images/\u0026#34; + newFilename); } catch (URISyntaxException e) { return Result.error(ExceptionEnum.UPLOAD_FAILED); } } /* 在该代码中，我们需要一个新的URI对象，是因为我们只关注URL中的主机信息（即协议、主机名和端口号），而不关注查询参数、片段等其他信息。因此，为了方便程序在之后的操作中引用这些主机信息，我们可以创建一个新的URI对象，其中仅包含协议、主机名和端口号。 另外，该代码中创建新的URI对象时使用了原来URI对象的一些属性，比如协议、用户信息、主机名和端口号等。这样可以确保创建的新的URI对象与原来的URI对象具有相同的协议、主机名和端口号，从而保证程序功能正确性。 */ private URI getHost(URI uri) { URI effectiveURI; try { effectiveURI = new URI(uri.getScheme(), uri.getUserInfo(), uri.getHost(), uri.getPort(), null, null, null); } catch (URISyntaxException e) { effectiveURI = null; } return effectiveURI; } 我们将文件上传到服务器之后，并不能直接通过链接来访问到我们的文件，这是因为没有配置资源映射：在Spring Boot中，需要将图片所在的目录配置为静态资源目录，否则系统无法找到图片。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Configuration public class WebMvcConfig implements WebMvcConfigurer { public final String FILE_UPLOAD_DIR = System.getProperty(\u0026#34;user.dir\u0026#34;) + \u0026#34;/images/\u0026#34;;; @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(\u0026#34;/images/**\u0026#34;) .addResourceLocations(\u0026#34;file:\u0026#34; + FILE_UPLOAD_DIR); //下面是一些映射其他静态资源的示例 // registry.addResourceHandler(\u0026#34;swagger-ui.html\u0026#34;).addResourceLocations( // \u0026#34;classpath:/META-INF/resources/\u0026#34;); // registry.addResourceHandler(\u0026#34;/webjars/**\u0026#34;).addResourceLocations( // \u0026#34;classpath:/META-INF/resources/webjars/\u0026#34;); } } springboot快速启动相关配置 \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.5\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;11\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;11\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;spring.boot.starter.web.version\u0026gt;3.0.5\u0026lt;/spring.boot.starter.web.version\u0026gt; \u0026lt;mybatis.version\u0026gt;3.0.2\u0026lt;/mybatis.version\u0026gt; \u0026lt;/properties\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.boot.starter.web.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.spring.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${mybatis.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; SpringBoot+Docker启动 compose Yml配置如下:\n1 2 3 4 5 6 7 8 9 10 11 12 version: \u0026#39;3.8\u0026#39; services: java-app: image: maven:3.9.6-amazoncorretto-8-debian-bookworm volumes: - .:/app - ./settings.xml:/usr/share/maven/conf/settings.xml working_dir: /app command: tail -f /dev/null stdin_open: true tty: true 这个采用的是非openjdk的maven镜像, 有需要的是因为openjdk中缺少javafx的包\nsettings.xml 和 SpringBoot项目需要复制一份放到docker-compose.yml的同一目录下\ncommand: tail -f /dev/null\n这个命令会使docker-compose run java-app 的时候卡在终端, 后续考虑换个后台执行的命令\ndocker exec -it 容器id /bin/bash 进docker container中, 找到pom.xml所在的目录, 然后执行 mvn spring-boot:run -Dmaven.test.skip=true 就可以跳过测试类的编译, 直接开始编译运行整个springboot项目 如果是 mvn spring-boot:run -DskipTests 那么只会跳过运行阶段的测试类, 不会跳过编译阶段, 有些时候测试类写的不完善会影响编译导致报错, 所以推荐使用第一种方式运行\n","permalink":"https://paper.3kis.top/posts/tech/springboot/","summary":"文件分享 指定项目的目录为文件上传目录 1 2 //System.getProperty(\u0026#34;user.dir\u0026#34;)会得到当前项目的根目","title":"SpringBoot"},{"content":"hash 表的创建\n字符串 hash\n哈希表的构建 哈希表的存储方式有两种, 分别是拉链法和开放地址法\n拉链法 拉链法中 h数组每个元素 h[i] 存储的是指向某个单链表的指针\n开放地址法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; //开放地址法使用的数组长度是输入数据量级的 2 到 3 倍. 现已已知输入数据量级为100000. 同时选取一个质数可更好地hash const int N = 200003; //0x3f3f3f3f是属于 10^9量级的数, 同时他比 10^9要大, 我们用这个数来定义为 null, 表示这个坑位里面没有元素 int h[N], null = 0x3f3f3f3f; //find函数返回 x 所在的位置, 如果 x 不存在,则返回他应该存入的位置 int find(int x) { //找到 x 应该存在的位置(下标) int k = (x % N + N) % N; //如果这个位置存在元素并且这个元素不是 x, 那么指针后移直到找到x所在的位置或者找到x应该存储的位置 while(h[k] != null \u0026amp;\u0026amp; h[k] != x) k++; //返回 x所在的位置 或 x应该存储的位置 return k; } int main() { int n; cin \u0026gt;\u0026gt; n; //因为h是int类型的数组一个int占用4个字节, memset可以对每个字节置为3f, 所以4个字节就是4个3f, 即 3f3f3f3f. 这样就可把每个int设置为上面定义的null了 memset(h, 0x3f, sizeof(h)); while(n--) { char op[2]; int x; scanf(\u0026#34;%s%d\u0026#34;, op, \u0026amp;x); //x所在的位置 或 x应该存储的位置 int k = find(x); //直接把这个位置的元素设置为 x if(op[0] == \u0026#39;I\u0026#39;) h[k] = x; else printf(\u0026#34;%s\\n\u0026#34;, h[k] != null ? \u0026#34;Yes\u0026#34; : \u0026#34;No\u0026#34;); //判断这个位置是否为null, 如果为 null,那么这个hash表中不存在x } return 0; } 字符串哈希 除了求循环结问题, 其他场景字符串 hash基本可以代替 kmp算法,\n","permalink":"https://paper.3kis.top/posts/tech/algorithm0225-hash/","summary":"hash 表的创建 字符串 hash 哈希表的构建 哈希表的存储方式有两种, 分别是拉链法和开放地址法 拉链法 拉链法中 h数组每个元素 h[i] 存储的是指向某个单链表的指针 开放","title":"hash"},{"content":"如何手写一个堆? 堆对外提供哪些 api ?\n① 插入一个元素\n② 求集合中的最小值\n③ 删除最小值\n延伸操作:\n④ 删除任意一个元素\n⑤ 修改任意一个元素\n堆的基本结构 堆是一个完全二叉树\n完全二叉树: 除了最后一层, 其它层全是非空节点. 最后一层的节点按照从左往右排列, 中间没有空节点\n小根堆的性质: 每一个节点都是小于等于左右儿子节点\n堆的存储方式 一维数组\n完全二叉树都是用一维数组存的\n堆的基本操作 一维数组 heap[] 和 数组长度 int size 来完成下面的操作\n数组存储所有元素, size 表示有效元素的长度\ndown 操作 down(x) 将指定元素下沉\n当我们修改一个元素后进行 down 操作, 过程如下图\nup 操作 up(x) 将指定元素上升\n如何从一个一维数组建堆 如果是每次插入一个元素就开始 down, 那么时间复杂度是 NlogN\n从 $\\frac{n}{2}$ 开始往树根 down 元素, 可以达到 O(N)的时间复杂度\n如下图, 对于树中到最后一层节点, 我们是不需要进行 down 操作的, 因为 他们没有儿子节点, down 了也没用, 所以我们从 $\\frac{n}{2}$ 开始往树根 down 元素, 也就是圈起来的那一层. 对于这一层, 有 n/4 个元素, 他们需要往下 down 1次, 在往上一层有 $\\frac{1}{2} * \\frac{n}{4} = \\frac{n}{8}$ 个元素, 他们需要往下 down 两次, 以此类推\n新增元素 直接作为一个新的节点插入到树上. 然后 up 这个节点, 是否能 up 成功, 我们会在 up 操作中判断\n修改元素 修改指定元素, 然后无脑执行 up 和 down 操作, 由于 up 操作和 down 操作会自动判断能否 up 或者 down, 所以肯定只有一个操作能成功, 就不需要再修改元素之后考虑应该 up 还是 down 了\n删除元素 让最后一个元素覆盖掉指定的元素, 然后 size\u0026ndash;. 并且对覆盖后的元素进行 down 操作\n取堆顶元素\u0026mdash;求集合当中的最小值 ","permalink":"https://paper.3kis.top/posts/tech/algorithm0219-heap/","summary":"如何手写一个堆? 堆对外提供哪些 api ? ① 插入一个元素 ② 求集合中的最小值 ③ 删除最小值 延伸操作: ④ 删除任意一个元素 ⑤ 修改任意一个元素 堆的基本结构 堆是","title":"heap"},{"content":"并查集优点 并查集是一种数据结构, 对于数据结构, 通常是能够帮助我们快速的执行一些操作才有必要创造出来. 对于并查集, 有如下两个优点\n① 快速的判断一个元素是否在集合 A 中\n② 快速的把两个集合合并\n推导过程 对于判断一个元素是否在集合 A 中可以很容易判断, 常规做法时间复杂度是 O(1), 但是对于把两个集合合并, 就需要遍历其中一个集合, 把遍历到的元素加到另一个集合中, 此时时间复杂度为 O(N).\n并查集是利用多叉树来存储数据, 一颗树就是一个集合. 如下图\n使用数组p[N]建立一个并查集, N表示节点数量或者可能的最大节点数. 对于一个数x, 加入到并查集中, 我们令 p[x] 作为 x 的父节点, 对于根节点, 我们令 p[x] = x\n对于一个并查集, 他有如下的操作\n① 如何判断树根? \u0026mdash; 节点能满足父亲节点是他自身p[x]=x\n② 找到一个节点的所在集合的编号(也就是找到祖宗节点) \u0026mdash;- 在一个并查集中, 只有祖宗节点能满足父亲节点是他自身p[x]=x, 所以找到祖宗节点可以使用 while 循环直到找到一个满足条件的节点 while(p[x] != x) x = p[x]\n③ 合并两个集合 \u0026mdash; 把集合 a 的祖宗节点接到祖宗 b 上, 让 a 整个成为 b 的儿子\n显然操作①是O(1)的, 操作③在操作②的结果上是 O(1)的.\n现在关键就在于操作 ②上, 对于常规的并查集, 我们要找到其祖宗节点, 必然是通过 while 循环来进行寻找, 这就有可能会导致时间复杂度过高. 如下图红色路径\n因此, 我们要优化整个过程.\n优化方式: 在需要祖宗节点的过程中, 每一个不是祖宗节点的节点, 修改其父节点为祖宗节点, 如下图\n该过程称为 路径压缩\n代码 1 2 3 4 5 //返回指定节点的祖宗节点 + 路径压缩 int find(int x){ if(p[x] != x) p[x] = find(p[x]); return p[x]; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int p[N]; //对于任意一个数, 返回其祖先节点. 并在寻找祖先的过程中进行路径压缩 int find(int x) { //如果当前节点不是祖先节点, 那么向上寻找祖先节点(等号右边的含义), 找到后, 设置当前节点的父节点为祖先节点(整个等号表达式的含义) if(p[x] != x) p[x] = find(p[x]); //由于此时父节点就是祖先节点, 故直接返回父节点 return p[x]; } int main(){ int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; //为每个点建立一个集合 for(int i = 1; i \u0026lt;= n; i++) { p[i] = i; } while(m--){ char op[2]; int a, b; scanf(\u0026#34;%s%d%d\u0026#34;, op,\u0026amp;a, \u0026amp;b); //合并操作, 让 a 节点的祖宗节点成为 b 节点祖宗节点的儿子 if(*op == \u0026#39;M\u0026#39;) p[find(a)] = find(b); else printf(find(a) == find(b) ? \u0026#34;Yes\\n\u0026#34; : \u0026#34;No\\n\u0026#34;); //通过祖宗节点是否相等来判断两个节点是否是同一集合 } return 0; } 题目:\n合并集合\n连通块中点的数量\n食物链\n","permalink":"https://paper.3kis.top/posts/tech/algorithm0217-union-finddatastructure/","summary":"并查集优点 并查集是一种数据结构, 对于数据结构, 通常是能够帮助我们快速的执行一些操作才有必要创造出来. 对于并查集, 有如下两个优点 ① 快速的判断一","title":"Union-findDataStructure"},{"content":"Trie树的作用: 快速存储和查找字符串集合的数据结构\n如何用 trie 树存字符串?\n这里提一点, trie 树存储的字符串数量和种类都不会很多, 要么全是小写字母, 要么全是大写字母, 要么全是数字\n对于下面的字符串集合\n1 2 3 4 5 6 abcdef abcd aced bcdf cdaa bcdd 其 trie 树如下图:\n对于一个 trie 树, 我们用一个二维数组$son[m][n]$表示, m 表示节点个数, n 表示一个节点所有可能的儿子数(路径数)\nm 一般需要根据题目的输入量级来决定\n$n$ 有如下几种可能: ①字母数量, 比如限定全是小写字母, 那么一个节点最多有$n=26$个儿子, 也就是最多 26 条路径 ②数字, 对于一个数字, 用其二进制表示, 那么最多是 $n=2$两种情况\nn 往往需要进行从字符到下标的映射或者从数字到下标的映射\n从字符到下标: int j = ch - 'a'\n从数字到下标: int j = number \u0026gt;\u0026gt; i \u0026amp; 1\n在上图中, 使用☆标记了每个字符串的结尾, 所以可以定义一个cnt[] 数组来记录每个字符串出现的次数\n图中每个节点是有值的, 但是这个值和字符串无关, 我们定义出一个 idx 指针来指向当前最新的节点, 并在每一次插入时把idx自增, 自增后的坐标值分配给新的节点. 这里 idx 和数组模拟链表中的指针含义类似\n模板:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 const int N = 100010; int son[N][26], cnt[N], idx; void insert(char* str) { int p = 0; for(int i = 0; str[i]; i++) { int u = str[i] - \u0026#39;a\u0026#39;; if(!son[p][u]) son[p][u] = ++idx; p = son[p][u]; } cnt[p] ++; } int query(char* str) { int p = 0; for(int i = 0; str[i]; i++) { int u = str[i] - \u0026#39;a\u0026#39;; if(!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; } int main(){ int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); char op[2], str[N]; while(n --) { scanf(\u0026#34;%s%s\u0026#34;, op, str); if(*op == \u0026#39;I\u0026#39;) insert(str); else printf(\u0026#34;%d\\n\u0026#34;, query(str)); } return 0; } 简化:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 int son[N][26], cnt[N], idx; // 0号点既是根节点，又是空节点 // son[][]存储树中每个节点的子节点 // cnt[]存储以每个节点结尾的单词数量 // 插入一个字符串 void insert(char *str) { int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - \u0026#39;a\u0026#39;; if (!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; } cnt[p] ++ ; } // 查询字符串出现的次数 int query(char *str) { int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - \u0026#39;a\u0026#39;; if (!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; } 详细注释版:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;iostream\u0026gt; using namespace std; //定义最大节点数量 const int N = 100010; //定义 模拟trie 树的 son 数组; 标记某个字符串出现的次数 cnt[]数组; 指向 trie 树的指针idx, 同时也能表示使用了多少个节点 int son[N][26], cnt[N], idx; //对于 son[N][26]的下标, 只看一维下标表示某个字符在trie树中的位置, 只看二维下标表示当字符为 N 中的一个时, 他的儿子的下标 //二维下标表示的是字符的映射位置, 所以不管是插入还是查询都需要对一个字符进行下标的映射, 当存储数字时同理 //对于son[i][j]整体: 当字符串 x 映射位置为 i 时, 字符串 y 映射到 j, 此时 son 数组是否有值, 如果有值则说明 y 是 x 的儿子 void insert(char* str) { //p 指向 root 节点, root 节点不存储数据 int p = 0; //遍历字符串 str 直到字符为空字符停止遍历 for(int i = 0; str[i]; i++) { //确定当前字符映射到 son 数组中的位置 int u = str[i] - \u0026#39;a\u0026#39;; //如果当前指向节点的儿子节点值为 0, 那么说明当前字符需要添加进 trie 树中. //我们借助 idx 来赋值, 同时让 idx 指向新的节点, 由于 idx=0 时指向root 节点,不存储数据, 所以要先将 idx 自增, 再赋值 //这里是将下一个坐标值赋予新的节点 if(!son[p][u]) son[p][u] = ++idx; //让 p 指针指向当前节点的子节点 p = son[p][u]; } //字符串遍历结束, 此时 p 指向字符串最后一个字符所在的节点, 我们对这个节点进行标记, 标记出当前节点是一个字符串的结尾 cnt[p]++; } int query(char* str){ int p = 0; for(int i = 0; str[i]; i++) { int u = str[i] - \u0026#39;a\u0026#39;; //查询操作, 没找到子节点, 说明当前字符不在 trie 树中, 那么直接返回0; if(!son[p][u]) return 0; p = son[p][u]; } //p指到了最后一个字符所在的 trie 树节点位置, 由于 cnt 做了字符串结尾标记, 故直接 cnt[p]即可得到字符串在trie树存了几次 return cnt[p]; } int main(){ int n; cin \u0026gt;\u0026gt; n; char op[2], str[N]; while(n--){ scanf(\u0026#34;%s%s\u0026#34;, op, str); if(*op == \u0026#39;I\u0026#39;) insert(str); else printf(\u0026#34;%d\\n\u0026#34;, query(str)); } return 0; } 题目 最大异或对\n这题可以理解数字如何通过二进制表示映射为数组中的二维下标\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;iostream\u0026gt; using namespace std; //一个数有 31 位, 所以 trie 树高为 31 层, 每层最多有 N 个数, 所以节点总数 M 为 31*N const int N = 100010, M = 31 * N; //一个节点最多有两个儿子(0 或 1), 所以二维下标长度为2 int son[M][2], idx; int a[N]; void insert(int x){ int p = 0; for(int i = 30; ~i; i--) { int u = x \u0026gt;\u0026gt; i \u0026amp; 1; //将下一个可分配的坐标值赋予新的节点 if(!son[p][u]) son[p][u] = ++idx; p = son[p][u]; } } int query(int x){ int p = 0, res = 0; for(int i = 30; ~i; i--) { int u = x \u0026gt;\u0026gt; i \u0026amp; 1; //对第 i 位下标的路径取反, 看看 trie 树上是否存在这个取反的结点 if(son[p][!u]) { //因为如果存在异或结果为1的数, 那么x和这个数异或之后, 第 i 位一定为 1, //那么1直接左移i即可得到对应的十进制数, 用res累加即可得到所有能异或为1的位的十进制数之和. //这样就不需要单独求出异或的数然后再拿x异或了 res += 1 \u0026lt;\u0026lt; i; p = son[p][!u]; }else{ p = son[p][u]; } } return res; } int main(){ int n ; cin \u0026gt;\u0026gt; n; for(int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); insert(a[i]); } int res = 0; for(int i = 0; i \u0026lt; n; i++) { res = max(res, query(a[i])); } cout \u0026lt;\u0026lt; res; return 0; } ","permalink":"https://paper.3kis.top/posts/tech/algorithm0215-trietree/","summary":"Trie树的作用: 快速存储和查找字符串集合的数据结构 如何用 trie 树存字符串? 这里提一点, trie 树存储的字符串数量和种类都不会很多, 要么全是小写字母,","title":"trieTree"},{"content":"关于 java 线程池等待队列长度的思考\n根据是否可以接受任务长时间等待作为切入点来进行队列长度的选择\n比如 hytrix 熔断, 他的底层实现就是 synchronousQueue, 因为他就需要响应快, 不能接受任务等待较长时间 比如有些任务, 是可以允许第二天再进入线程池执行的, 这种就可以把等待队列设置长一点, 让这些任务等久一点也无所谓, 甚至在有大流量冲击的时候, 长的等待队列还能起到一个缓冲的作用 ","permalink":"https://paper.3kis.top/posts/tech/java-threadpool/","summary":"关于 java 线程池等待队列长度的思考 根据是否可以接受任务长时间等待作为切入点来进行队列长度的选择 比如 hytrix 熔断, 他的底层实现就是 synchronousQueue, 因为他就需要响应快,","title":"Java 线程池任务队列的思考"},{"content":"markdown 自带上标下标 该功能不是所有的 markdown 渲染器都支持, 所以更建议使用 latex 来表示上下标\nb~1~ \u0026ndash;\u0026gt; b~1~\nb^2^ \u0026mdash;\u0026gt; b^2^\nb^3x-2^ \u0026mdash;\u0026gt; b^3x-2^\n开启 latex 公式 使用两个美元符号把公式内容包裹住 $ latex $\n在 latex 中使用上标和下标 上标 ^ $10^2$ \u0026mdash;\u0026gt; $10^2$\n$10^{20-x}$ \u0026mdash;-\u0026gt; $10^{20-x}$\n下标 _ $a_i$ \u0026mdash;\u0026gt; $a_i$\n$a_{i+1}$ \u0026mdash;\u0026gt; $a_{i+1}$\n在 latex 中使用求和公式 $\\sum_{i=1}^{n} i$ \u0026ndash;\u0026gt; $\\sum_{i=1}^{n} i$\n在 latex 中写分数 $\\frac{n(n+1)}{2}$ \u0026mdash;\u0026gt; $\\frac{n(n+1)}{2}$\n在 latex 中使用空格 \\; 表示大一些的空格, 比如 a\\;b 的效果为 $a;b$\n\\,表示小一些的空格, 比如 a\\,b 的效果为 $a,b$\n在latex 中换行 \\\\ 用于换行\n\\newline 也可用于换行, 更推荐这个\n在 latex 中表示~ \\sim{} ===\u0026gt; $\\sim{2}+1$\n","permalink":"https://paper.3kis.top/posts/tech/markdownsyntax/","summary":"markdown 自带上标下标 该功能不是所有的 markdown 渲染器都支持, 所以更建议使用 latex 来表示上下标 b~1~ \u0026ndash;\u0026gt; b~1~ b^2^ \u0026mdash;\u0026gt; b^2^ b^3x-2^ \u0026mdash;\u0026gt; b^3x-2^ 开启 latex 公式 使用两个美元符号把公式内容包裹住 $ latex $","title":"markdown latex 语法"},{"content":"差分是前缀和的逆运算\n对于数组 $a_1, a_2, a_3, \\ldots, a_n$ 和数组$b_1, b_2, b_3, \\ldots, b_n$ 如果 $a_i = b_1+b_2+b_3+..+b_i$, 那么我们称 a 数组是 b 数组的前缀和, b 数组是 a 数组的差分. 对于任意 bi 有 $b_i = a_i - a_{i-1}$\n由上可得$a_i$与 $b_i$的关系, 那么反过来 $b_i = f(a_i) ?$\n$$ \\begin{aligned} b_1 \u0026amp;= a_1 \\newline b_2 \u0026amp;= a_2 - a_1 \\newline b_3 \u0026amp;= a_3 - a_2 \\newline \u0026amp; \\ \\vdots \\newline b_n \u0026amp;= a_n - a_{n-1} \\end{aligned} $$\n差分有什么用? 假设我们已经有b 数组了, 那么我们如果想要求a数组, 只要求一遍前缀和就可以了.\n那么我们就可以 以 O(N)的时间从 b 数组得到 a 数组\n回忆下前缀和的作用是什么呢? \u0026mdash; 快速求区间和\n对于给定的区间 [l, r] , 让 a 在这个区间的数全部加上常数c , 如果暴力遍历这些数那么就是 O(N)的\n但是如果用差分来做的话就可以做到 O(1)\n为什么呢?\n考虑当我们对 a 数组做了加常数 c 的操作, b 数组发生了什么变化? 或者说 b 数组的什么操作能使得 a 数组在指定区间内的数都加上 c\n其实就是对 $b_l $ 加上常数 c 之后再求前缀和即可得到 $a_l + c$ .\n当我们对$b_l+c$之后, 会导致 原数组的 [$a_l, a_{l+1}, a_{l+2},\u0026hellip;, a_r, a_{r+1}, a_{r+2},\u0026hellip;,a_n$]这些数全部加上 c, 也就会变成 [$a_l+c, a_{l+1}+c, a_{l+2}+c,\u0026hellip;, a_r+c, a_{r+1}+c, a_{r+2}+c,\u0026hellip;,a_n+c$]\n但是我们只需要让 [$l,r$]之间的数加上常数 c, (r+1)之后的数不能加上 c, 所以我们就得打一个补丁来进行修正, 也就是让 $b_{r+1} - c $ , 这样(r+1)之后的原数组的数就不会加上 c 了. 如下图所示\n原本我们想要让前缀和数组的数在 [$l,r$]之间的数加上c需要 O(N)的时间复杂度, 现在我们只需要修改差分数组的两个数$b_l 和 b_{r+1}$就可以O(1)了\n那么我们就可以得到一个公式来通过 b 数组保证 a 数组只有指定范围内会变化, 公式如下\n1 2 3 4 void insert(l, r, c){ b[l] += c; b[r+1] -= c; } 假设 a 数组全部是 0, 那么差分数组 b 也就全部是 0 \u0026mdash;- 这是我们不需要考虑构造 b 数组的关键, 我们只需要考虑插入就可以了\n但是现在 a 数组不是 0, 我们可以看成是让原数组进行了 n 次加c操作进而得到了a 数组, 第一次是让数组[1,1]加上$a_1$,第二次是让原数组[2,2]区间加上 $a_2$ ,第三次是让原数组[3,3]区间间加上 $a_3$ , 一直到第 n 次是让原数组[n,n]区间加上了 $a_n$\n我们知道, 要让原数组a加上c只需要在差分数组中进行 $b_l + c$ 和$b_{r+1}-c$ 即可, 那么在这里就是 $(b_1 +a_1$ \u0026amp;\u0026amp; $b_2-a_1)$ 即可确定对应原数组中区间[1,1]的数, $(b_2+a_2 $ \u0026amp;\u0026amp; $ b_3-a_2)$ 即可确定原数组区间[2,2]的数, 以此类推 $(b_n+a_n$ \u0026amp;\u0026amp; $b_{n+1}-a_n)$原数组区间[n,n]的数.\n对于原地插入, 直接调用函数 insert(1,1,a[1]); insert(2,2,a[2]); insert(3,3,a[3]); .... insert(n,n,a[n]); 即可保证能从b 数组求出前缀和\n要利用 b 数组原地(空间复杂度O(1))求前缀和, 直接 $b_i = b_i+b_{i-1}$ 这样遍历后的的 b 数组直接和 a 数组的值一样了\n求前缀和是一个递推过程\n所以在实际使用中, 我们不需要考虑如何构造差分数组, 只需要让原数组都为 0, 然后遍历本来应插入的值, 由差分数组进行插入即可\n二维差分 一维差分的作用是对一段区间加上一个值, 那么二维差分就是给某一块子矩阵加上值\n对于 差分矩阵 $b_{ij}$ , 对于指定的 i , j 所指向的元素加上常数 c , 其影响就是对应前缀和矩阵的 i, j 右下方所有元素都会加上常数c\n所以, 我们如果想要指定前缀和矩阵 $(x_1, y_1)$ 和 $(x_2, y_2)$ 之间的所有元素加上常数的话, 就要借助 b 矩阵打个补丁.\n1 2 3 4 5 6 void insert(int x1, int y1, int x2, int y2, int c){ b[x1][y1] += c; b[x2+1][y1] -= c; b[x1][y2+1] -= c; b[x2+1][y2+1] += c; } 如下图\n二维求前缀和的递推公式为\n1 b[i][j] = b[i-1][j] + b[i][j-1] + b[i][j] - b[i-1][j-1] ","permalink":"https://paper.3kis.top/posts/tech/algorithm1230-difference/","summary":"差分是前缀和的逆运算 对于数组 $a_1, a_2, a_3, \\ldots, a_n$ 和数组$b_1, b_2, b_3, \\ldots, b_n$ 如果 $a_i = b_1+b_2+b_3+..+b_i$, 那么我们称 a 数组是 b 数组的前缀和, b 数组是 a 数组的差分. 对于任意 bi 有","title":"差分"},{"content":"双指针 双指针(Two pointers)有两大类\n情况一: 两个指针指向两个不同的序列, 比如归并排序\n情况二: 两个指针指向同一个序列, 这种出现的更多一些, 比如快排\n一般的写法只有一种:\n1 2 3 4 5 6 7 8 //一重循环, i 从 0开始, j 从某个点开始, 这里以 0 开始作为演示. 然后 i 把整个序列扫描一遍 for(int i = 0, j = 0; i \u0026lt; n; i++){ //对于 j, 每次 i 更新完之后我们要更新我们的 j, 第一个判断条件是 j 的范围, 一定确保 j 在 合法范围 内,这里用 j\u0026lt;i 来演示. //第二个条件就是满足某一个性质, 两个条件都满足, 则j++ while(j \u0026lt; i \u0026amp;\u0026amp; check(i,j)) j++; //题目本身的逻辑 } 解释: 让i把数组扫描一遍, j与i以某种性质维护一个区间\n解题思路: 先用朴素算法O(N^2)来暴力解决问题, 然后看i j之间他们有没有单调关系, 有单调关系则利用单调关系套用模板把整个枚举的状态数量从N^2变为N\n最长连续不重复子序列\n判断子序列\n位运算 位运算最常用的两种操作 ①看 n 的第 k 位数字是几 ②lowbit\u0026ndash;树状数组基本操作\n看 n 的第 k 位数字是几 一个整数 n, 其二进制表示中第 k 位数字是几, k从 0 开始计数\nn=15 ==\u0026gt; n=(1111)~2~\n①先把第 k 位移到最后一位: n \u0026raquo; k\n②看个位是几, 公式是$x\u0026amp;1$\n结合①②, 可得要求 n 的二进制第 k 位的公式为: $n \u0026raquo; k ;\u0026amp; 1$\n对于一个十进制数x, 如果我们从最高位(比如 32 位, 从 k=32)开始打印这个数,那么打印完之后得到的就是x 的二进制表示\nlowbit\u0026ndash;树状数组基本操作 lowbit(x) : 返回 x 的最后一位 1和后面的二进制数\n举例\nlowbit(1010~2~) = 10\nlowbit(1000~2~) = 1000\nlowbit实现方式\n$x \u0026amp; -x$\n在 c++中, 一个整数的负数是原数的补码(补码是取反加一), 所以 -x 的二进制表示和 ~x+1( x取反加一)的二进制表示是一样的\n∵-x = ~x+1\n∴x\u0026amp;-x ==\u0026gt; x\u0026amp;(~x+1)\n推导过程:\n![lowbit 推导过程](lowbit 推导过程.jpeg)\n~表示取反\n应用\n求 x 里面 1的个数\n每次将 x 中的 最后一个 1 减去, 直到x 变为 0, 我们记录减了几次, 就可以知道有多少个 1\n题目:二进制一的个数\n原码,反码,补码 补充 令 x=1010~2~ 假设是 32 位整数\n原码: 0000\u0026hellip;..01010\n反码: 0111\u0026hellip;..10101 原码除符号位外取反\n补码: 0111\u0026hellip;..10110 反码加一 ~x+1\n为什么要有补码?\n因为在计算机里面没有减法, 需要用加法来做减法\n一个x 加上他的相反数-x 应该等于 0: x+(-x)=0\n那么有如下推导\n$(-x) = 0-x\\(-x)=(32个 0)_2 - x\\此时做减法,32个 0 会往前借一位,也就是\\(-x)=(1+后面32个 0)-x\\此时\\(1+后面32 个 0)-x = \\sim{x} + 1\\故\\减法用\\sim{x+1}这个补码表示$\n正数和零的原码表示和补码表示是一样的, 不需要专门求补码, 直接用原码表示\n二分查找 二分的作用 二分用来干嘛? 用来找到满足某种性质的区间的边界\n二分查找有两种写法, 应对的场景不同, 从代码上看最核心的区别在于求 mid 下标时是否需要加一来求出 mid 下标\n二分的本质 存在一个性质, 通过这个性质我们可以把整个区间分成左右两个部分, 使得右半部分满足这个性质, 左半部分不满足这个性质, 左右两边没有交点(整数二分)\n如果这个性质存在, 那么就可以通过二分来找到满足性质的区间的边界点\n如上图, 找到左边界的端点(红色点)或者找到右边界的端点(绿色点)对应的就是两个模板\n找红点 来看看找到红点对应的模板:\n二分分成以下几步\n①找到中间点 mid\n​\t$mid=\\frac{l+r+1}{2}$ 然后判断这个中间点是否满足我们的红色性质\n​\tif(check(mid))\n② a. check 为 true , 那么说明 mid 一定满足红色性质, 那么此时答案一定在 [mid, r] 之间, 因为 mid 有可能是答案, 所以是闭区间, 因为我们要找的是端点, 所以肯定不会在已经满足性质的 mid 左边, 那么这个时候我们就可以更新区间为 $[mid, r]$ 则令 l=mid\n② b. check 为 false, 那么说明 mid 不满足红色性质, 此时答案一定在 mid 的左边, 那么更新区间为 $[l, mid-1]$, 则令r=mid-1\n1 2 3 4 5 6 7 8 int binarySearchLPoint(int l, int r) { while(l \u0026lt; r) { int mid = l + r + 1 \u0026gt;\u0026gt; 1; if(check(mid)) l = mid; else r = mid-1; } return l; } 找绿点 来看看找到红点对应的模板:\n二分分成以下几步\n①找到中间点 mid\n​\t$mid=\\frac{l+r}{2}$ 然后判断这个中间点是否 满足我们的红色性质\n​\tif(check(mid))\n② a. check 为 true, 那么说明 mid 一定满足绿色性质, 此时答案一定在[l, mid]之间, 因此,更新区间为$[l, mid]$, 则令r=mid\n②b. check 为 false, 那么说明 mid 不满足绿色性质, 此时答案一定在 mid 的右边, 因此更新区间为$[mid+1, r]$, 则令l=mid+1\n1 2 3 4 5 6 7 8 int binarySearchRPoint(int l, int r) { while(l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if(check(mid)) r = mid; else l = mid+1; } return l; } 使用二分的考虑事项 直接写出 mid = l + r \u0026gt;\u0026gt; 1\n考虑 check 函数为 true时区间是如何变化的, 如果变成 l=mid, 那么回过头来修改第一步的 mid = l + r + 1 \u0026gt;\u0026gt; 1 , 如果变成 r=mid\n确定把区间一分为二的性质到底是什么,也就是 check 函数到底是什么 然后根据这个性质判断我应该如何变换区间才能找到想要的边界点.\n该性质把我想要的数放到了右区间, 那么我就只能找想要的数的第一个点, 即 r = mid. 因为后面的点就无法通过性质去取到了, 所以只能去找第一个点\n该性质把我想要的数放到了左区间, 那么我只能找想要的数的最后一个点, 即 l = mid; mid=l+r+1\u0026gt;\u0026gt;1 , 因为左边的点无法通过性质去取到想要的值了, 所以只能找最后一个点\n理解这第三点很重要!!!\n除非是专门找起点终点, 不然直接默认找第一个点就行, 也就是:\n$mid = l + r \u0026raquo; 1$\ncheck函数保证想要的数出现在右区间\nQ\u0026amp;A\nQ1 为什么找红点的时候 mid 需要+1 再求\nA1 假设我们不加一看看会发生什么: 因为当 $l = r-1$ , 也就是 $l 和 r$是相邻的时候, 由于大多数编程语言都是向下取整, 所以此时求出来 $mid = \\frac{l+r}{2} = \\frac{l+l+1}{2} = \\frac{2l}{2} + \\frac{1}{2}向下取整没了= l$ , 即 $mid = l$ , 然后进行区间更新l = mid= l , 那么那么这次循环就没把区间更新, 就会导致死循环,\n如果加一了, 那么区间就能更新为 l=l+1=r , 此时就可以正常退出 for 循环了\nQ2 单调性和二分的关系是什么?\nA2 有单调性必定能用二分, 用二分不一定有单调性. 单调性只是我们让我们使用二分的性质之一, 但不是唯一\n练习题: 数的范围\nDiscretization离散化 离散化特指整数的离散化, 且是有序的离散化\n离散化的含义: 有一些数, 值域比较大$[0,10^9]$ , 数量不多,大概是$10^5$个\n有些题目, 我们可能需要以这些值为下标, 但是我们又不想开一个长度为$10^9$的数组, 所以我们需要一种方式把这$10^5$个数映射到连续的数$[0,n-1]$上\n离散化: 对于数组 a, 有 $1 ,3,100,2000,10000$ 这五个数, 我们把他映射到从 0 开始的自然数$[0,1,2,3,4]$, 这个过程就叫做离散化\n可能遇到的问题:\na 中可能有重复元素 \u0026mdash;\u0026ndash;\u0026gt; 需要去重 如何快速算出任意值 $x$ 离散化后的值 \u0026mdash;-\u0026gt; 利用数组有序,然后二分求下标 离散化比较明显的好处就是节省空间\n为这组数组建立离散化对应的下标: list+二分\n现将所有的数存到 list 中, 去重, 排序.\n二分拿到数在 list 中的下标\n这样, 就能完成离散化的下标映射, 接下来就是利用这个新下标来做别的事情, 比如求区间和之类的\n题目:\n区间和\n格子染色\n区间合并 区间合并应用场景: 如果给了我们很多区间, 这些区间有交集的话, 我们可以通过接下来介绍的方式迅速把两个区间合并成同一个区间\n合并过程中的问题的边界问题\u0026mdash;- 如果两个区间只有端点相交那么我们认为这两个区间也是可以合并的\n合并的过程 根据所有区间的左端点进行排序\n维护一个区间, 然后从第1 个区间开始, 有三种情况要考虑\n情况①: 下一个区间在当前区间内(有可能右端点重合), 那么更新右端点为两者较大的点(max 函数), 继续\n情况②: 下一个区间与当前区间有交集, 那么更新当前维护区间的右端点为下一个区间的右端点, 继续\n情况③: 下一个区间与当前区间没有交集, 那么把当前维护的区间放到答案里里去, 然后让维护的区间变成下一个区间\n三种情况如下图所示\n​\t情况②展示:\n模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 typedef \u0026lt;int, int\u0026gt; PII; void intervalMerge(vector\u0026lt;PII\u0026gt; \u0026amp;input) { vector\u0026lt;PII\u0026gt; res; int st = -2e9, ed = -2e9; sort(input.begin(), input.end()); for(auto item : input) { if(ed \u0026lt; item.first) { if(st != -2e9) res.push_back({st, ed}); st = item.first, ed = item.second; }else{ ed = max(ed, item.second); } } if(st != -2e9) res.push_back(st, ed); input = res; } 注释:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 typedef \u0026lt;int, int\u0026gt; PII; void intervalMerge(vector\u0026lt;PII\u0026gt; \u0026amp;input) { vector\u0026lt;PII\u0026gt; res; //维护区间 int st = -2e9, ed = -2e9; //排序, 以左端点从小到大排序, 对于 PII 中, sort 函数会先排序左端点, 再左端点相同时排序右端点 sort(input.begin(), input.end()); //开始遍历区间 for(auto item : input) { //如果当前区间的右端点严格小于下一个区间的左端点, 那么说明两者无交集, 此时①添加答案②更新端点 if(ed \u0026lt; item.first) { //注意, 只有维护的区间不是负无穷的区间时, 添加的答案才有意义, 所以要进行一次判断 if(st != -2e9) res.push_back({st, ed}); //更新区间为下一个区间 st = item.first, ed = item.second; }else{ //区间的右端点大于等于下一个区间的左端点, 对应情况①和情况②, 情况二可直接ed=item.second, 但由于情况一的存在, 所以不能直接ed=item.second, 应该做一个max来校验 ed = max(ed, item.second); } } //1. 最后一个区间如果和前面的区间是没有交集的, 那么在for循环中会漏掉, 没添加这个区间到结果里, 所以这里要给他加上 //2. 区间一直在合并, 没有添加区间到答案里, 这里要加上 //3. 最后两个区间合并了, 没有添加区间到答案里, 这里要加上 if(st != -2e9) res.push_back(st, ed); //将 res 赋给 input, 这样调用方就能拿到更新好的结果了 input = res; } 题目:\n区间和\n链表\u0026amp;栈 author = \u0026ldquo;Asher\u0026rdquo; title = \u0026ldquo;链表\u0026amp;栈\u0026rdquo; date = \u0026ldquo;2024-01-21T10:33:12+08:00\u0026rdquo; description = \u0026quot;\u0026quot; draft = false\n+++\n单链表\n双链表\n栈\n关于链表, 我们采用数组模拟的方式, 而不是以创建 struct 的方式, 因为new 一个 struct 太慢了, 数据量达到百万级的时候性能低\n单链表 用途: 创建邻接表. (邻接表的用途是用来存储树或图)\n模拟方式如下:\n链表中每个点存两个值: ①自己的 val ②下一个节点的指针\n采用两个数组, e数组和 ne数组, e数组用来存储当前节点的值, ne数组用来存储当前节点的下一节点的指针(也就是当前节点的下一个节点在什么位置==\u0026gt; 下一个节点的下标是什么)\ne[i]: 位置为 i 的节点的 value\nne[i]: 位置为 i 的节点指向的下一个节点的位置, 还是一个下标\ne数组和 ne数组关联的方式是下标来关联\n那么对于链表的每个点, 他有两个值, 一个是 e, 一个是 ne, 他们使用下标关联起来的\n构造一个单链表并给基本的操作方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 const int N = 100010 int e[N], ne[N], head, idx; void init(){ head = -1; idx = 0; } void addToHead(int x) { e[idx] = x; ne[idx] = head; head = idx; idx++; } void add(int k, int x) { e[idx] = x; ne[idx] = ne[k]; ne[k] = idx; idx++; } void remove(int k) { ne[k] = ne[ne[k]]; } 注释版\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 //构建静态链表的大小----数组模拟链表就是构建了一个静态链表 const int N = 100010; //head始终表示头结点的下标, idx 表示的是当前操作节点的下标 int e[N], ne[N], head, idx; //初始化链表 void init(){ //head=-1说明当前为空集 head = -1; //idx=0表示要操作的节点的下标为 0 idx = 0; } //向链表头插入一个数； void insertHead(int x) { /* 1. 把这个数存到节点里 2. 让这个节点指向当前的头结点 3. 让 head 指向当前节点 4. idx++, 让他指向下一个要操作的节点 */ e[idx] = x; ne[idx] = head; head = idx; idx++; } // 删除下标为 k 的后一个节点 void remove(int k) { /* 1. 找到下标为 k 的节点的下一个节点的下一个节点 2. 更新下标为 k 的节点的下一个节点 */ //ne[k]表示下一个节点的位置, 由于ne[i]表示节点i的下一个节点位置, 所以 ne[ne[k]]表示下标为k的节点的下一个节点的下一个节点 ne[k] = ne[ne[k]]; } //在下标为k的节点后插入一个节点 void insert(int k, int x) { /* 1. 把这个数存到节点里 2. 让当前操作节点指向下标 k 的节点的下一个节点 3. 让下标为k 的节点指向当前节点 4. 更新 idx 到下一个要操作的节点, idx++ */ e[idx] = x; ne[idx] = ne[k]; ne[k] = idx; idx++; } 题目:\n单链表\n单链表可能只能建立一个数组模拟链表的初步印象, 在\u0026quot;寻找节点\u0026quot;这一点上, 双链表可以加深理解\n双链表 用途: 优化某些问题\n单链表的每个节点只有一个指针, 这个指针指向后一个节点\n双链表每个节点有两个指针, 一个指针指向前, 另一个指针指向后\n对于双链表, 我们直接用数组的 0 位表示 head节点, 1 位表示 tail节点, $l[i]$数组表示下标为 i 的节点的左指针, $r[i]$表示下标为 i 的节点的右指针\n初始化 让 head节点右指针指向1(tail节点下标), tail节点左指针指向 0(head 节点下标). 表示空链表. 两个点不表示实质内容, 只表示边界节点\n添加节点操作 对于在下标为 k 的节点后面添加节点, 需要① 把新的值存进去 ②让新的节点右指针指向 k 节点的右节点 ③让新节点的左指针指向k 节点的右节点的左节点 ④让 k 节点的右节点的左指针指向当前节点 ⑤让 k 节点的右指针指向当前节点\n其中④⑤不能调换顺序, 因为我们只能通过 k 先找到右节点, 然后再把k节点的原右节点的左指针指向当前节点. 如果调换顺序我们就无法通过下标和 r[i]找不到 k 节点的原右节点了\n对于在下标为 k 的节点前面添加节点, 那么我们就直接找到下标为 k 的节点的左节点, 然后再调用添加节点到右边的方法就可以了\n找到下标为 k 的节点的左节点的方式就是通过 k 来找到, 即 $l[k]$\n删除节点操作 也就是让下标为 k 的节点的左节点右指针指向下标为 k 的节点的右节点, 让下标为 k 的节点的右节点的左指针指向下标为 k 的节点的左节点.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 const int N = 100010; int e[N], l[N], r[N], idx; void init(){ r[0] = 1; l[1] = 0; idx = 2; } void add(int k, int x){ e[idx] = x; r[idx] = r[k]; l[idx] = k; l[r[k]] = idx; r[k] = idx; idx++; } void remove(int k) { r[l[k]] = r[k]; l[r[k]] = l[k]; } 为什么没有插入头结点的操作?\n因为我们没有空指针, 所以直接使用 add 方法来找到对应的位置即可插入头结点\n注释\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 //声明静态链表长度, 一般由输入的数据量决定 const int N = 100010; //e[i]表示下标为i的节点的值, l[i]表示下标为i的节点的左指针(左节点下标), r[i]表示下标为i的节点的右指针(右节点下标), idx 表示正在处理的节点的下标 int e[N], l[N], r[N], idx; //双链表使用两个节点来初始化, 分别是 head 节点和 tail 节点, 互相指向表示空链表, 同时这两个节点可以定义出链表的边界 void init(){ //让 head 节点指向 tail 节点 r[0] = 1; //让 tail 节点指向 head 节点 l[1] = 0; //由于 0 1 位置被占用了, 所以 idx 从 2 开始 idx = 2; } //add操作表示在 idx 为 k 的节点右边插入节点 void add(int k, int x){ //存储节点值 e[idx] = x; //让当前操作节点右指针指向下标为k的节点的右节点 r[idx] = r[k]; //让当前操作节点左指针指向下标为k的节点 l[idx] = k; //让下标为k的节点的右节点的左指针指向当前节点 l[r[k]] = idx; //让下标为k的节点的右指针指向当前节点 --- 这一步不能和上一步调换 r[k] = idx; //操作下一个节点 idx++; } //注意: 这里的 k 指的值要执行的节点下标而不是说删除第 k 个节点的右一个节点 --- 这是和单链表不同的地方 void remove(int k) { //让待删除节点的 左节点的右指针 指向 待删除节点的右节点 r[l[k]] = r[k]; //让待删除节点的 右节点的左指针 指向 待删除节点的左节点 l[r[k]] = l[k]; } 单链表和双链表的区别 我们都是用数组来模拟链表, 但是这里的模拟方式有区别\n① 单链表有空指针, 所以有head 可以为 -1\n​\t双链表不表示空指针, 而是直接用固定的两个点0 1 表示 head 节点和 tail 节点, 但是这两个节点不存储任何数据, 仅仅用来限制整个链表的边界\n② 初始化方法不同\n​\t单链表由于存在空指针, 所以一开始直接让 head 为空指针-1\n​\t双链表不存在空指针, 所以用两个端点互相指向来完成初始化\n③ 单链表的 head 是表示下标(指针的含义); 双链表的 head, tail 表示的是不存储数值的节点\n④ 删除节点操作在单链表中指的是删除 idx 为k 的下一个节点, 在双链表中指的是 idx 为 k 的这个节点本身. 添加节点则和单链表意思一致\n题目\n双链表\n栈 数组模拟栈\n1 2 3 4 5 6 7 8 9 10 11 const int N = 1000010; //tt 表示栈顶指针, 这里我们以 0 表示栈中没有元素 int stk[N], tt; //向栈顶插入元素 stk[ ++ tt ] = x; //弹出元素 tt--; //获取栈顶元素 stk[tt]; //判空 if(tt \u0026gt; 0) not empty 队列 数组 q[N] , 使用 head 指向队头, tail 指向队尾.\n初始化: head=0, tail=-1;\n插入: q[++tail] = val\n删除: head++\n判空: head\u0026lt;=tail 不为空\n读取队头元素: q[head]\n单调栈 应用场景: 给定一个序列, 求出这个序列中 每一个数 左边最近的比他小的数\n1 2 序列: 3\t4\t2\t7\t5 ans: -1\t3\t-1\t2\t2 思考过程: 先暴力再优化(类似双指针)\n暴力: 要找每一个数左边最近的比他小的数, 那么就可以直接遍历每一个数, 然后对于遍历到的数, 遍历其左边的数\n1 2 3 4 5 6 7 8 9 for(int i = 0; i\u0026lt; n; i++){ for(int j = i - 1; j \u0026gt;= 0; j--){ if(arr[i] \u0026gt; arr[j]) { cout \u0026lt;\u0026lt; arr[j] \u0026lt;\u0026lt; endl; break; } } cout \u0026lt;\u0026lt; \u0026#34;-1\u0026#34; \u0026lt;\u0026lt; endl; } 优化: 对于遍历到的数x, 我们把他左边的数放到栈中, 如果当前栈顶元素大于等于x, 那么就说明栈顶元素肯定不是我们需要的, 所以把栈顶元素弹出, 一直找到小于 x 的栈中元素然后停止弹出, 把这个元素输出来, 接下来把 x 加入栈中.\n这样做的好处是我们能保证数 x 加入栈之后, 他的左边一定不会有比他大的数, 那么当我们开始遍历 x 右边的数时, 已经被弹出去的栈元素(大于或等于 x)的元素一定不会成为x右边数的答案, 因为 x 是最近的. 这样, 我们就在栈中构成了一个单调增的序列, 也就是单调栈.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 const int N = 100010; int a[N]; int stk[N], tt = 0; void pop(){ tt--; } void push(int x) { stk[++ tt] = x; } bool empty() { return !(tt \u0026gt; 0); } int query() { return stk[tt]; } void find(int n){ for(int i = 0; i \u0026lt; n; i++) { while(!empty() \u0026amp;\u0026amp; query() \u0026gt;= a[i]) { pop(); } if(empty()) { cout \u0026lt;\u0026lt; \u0026#34;-1\u0026#34; \u0026lt;\u0026lt; \u0026#34; \u0026#34;; }else { cout \u0026lt;\u0026lt; query() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } push(a[i]); } } 单调队列 应用场景: 滑动窗口中的最大值和最小值\n单调队列优化过程: 先考虑暴力怎么做? 然后把其中没有用的元素删掉, 得到单调性, 有单调性的话当我们去求极值, 就可以直接从队列中拿第一个点或最后一个点了\n单调队列: 队头出队, 队尾出队入队(注意: 单调队列的队尾是可以出队的)\n关于单调栈和单调队列的使用方法\n我们先考虑使用栈或者队列时暴力做法是什么? 然后把栈或队列中没有用的元素删除, 观察剩下的元素是否有单调性, 有单调性的话再看看怎么优化这个问题\nKMP算法 kmp实际上是对字符串匹配的优化算法.\n对于字符串s和字符串 p, 要找到 p 在 s 中的位置, 那么暴力算法是以字符串的每个字符作为起点, 然后逐个比较 p 和 s 的字符, 若p的字符遍历完都是相等的, 那么说明我们找到了p 在 s 中的位置\n暴力算法的时间复杂度是O(mn), m n 为两个字符串的长度\n在整个过程中, 匹配到某一个字符 c 失败时, 那么在 c 之前很有可能有已经匹配的子串, 这部分子串是很重要的信息, 但是在暴力算法中完全忽略了, 在 kmp 中, 我们可以利用这部分已经匹配的子串来找到我们下一次应该遍历的起点, 这就优化掉了暴力算法中总是从 p 的开头开始匹配的缺陷.\n具体做法如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 const int N = 100010; const int M = 1000010; char p[N], s[M]; int main(){ int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; p + 1 \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s+1; int ne[N]; for(int i = 2, j = 0; i \u0026lt;= n; i++) { while(j \u0026gt; 0 \u0026amp;\u0026amp; p[i] != p[j + 1]) j = ne[j]; if(p[i] == p[j + 1]) j++; ne[i] = j; } for(int i = 1, j = 0; i \u0026lt;= m; i++) { while(j \u0026gt; 0 \u0026amp;\u0026amp; s[i] != p[j+1]) j = ne[j]; if(s[i] == p[j+1]) j++; if(j == n) { j = ne[j]; printf(\u0026#34;%d \u0026#34;, i - n); } } return 0; } 极简版本:\n注释版本:\nj 始终从 0 开始, 我们利用 j+1 来进行下一个位置的预判匹配, 匹配成功才让 j++\n整个过程中, 只有 j 能退\n$$ne[i]$$ 数组的定义:数组 $$p[1,i]$$ 的最长前后缀长度( 注意 1 为数组第一个元素)\n前后缀指的是小于当前字符串长度的前后缀\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 const int N = 100010; const int M = 1000010; char p[N], s[M]; int main(){ int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; p + 1 \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s+1; int ne[N]; for(int i = 2, j = 0; i \u0026lt;= n; i++) { //注意是 j+1 来预判 while(j \u0026gt; 0 \u0026amp;\u0026amp; p[i] != p[j + 1]) j = ne[j]; //经过 while 循环之后, 如果一直不相等, 那么 j 会回到 0 位置, 此时 while 就没法帮助继续回退了 //应该在新的 if 中预判下一个字符是否匹配, 所以不能无脑 j++ if(p[i] == p[j + 1]) j++; ne[i] = j; } for(int i = 1, j = 0; i \u0026lt;= m; i++) { //注意是 j+1 来预判 while(j \u0026gt; 0 \u0026amp;\u0026amp; s[i] != p[j+1]) j = ne[j]; //当不匹配的情况都回退之后, 我们还需要手动给j右移一位加一 //注意是 j+1 来预判 if(s[i] == p[j+1]) j++; if(j == n) { //让 j 回到上一次匹配的位置, 利用之前的最长真前后缀(真前后缀长度必小于n)再次进行匹配, //如果之后还是匹配成功了, 那么j++还是有可能回到j==n的情况, 此时就可无限匹配后面的字符串 j = ne[j]; //如果打印语句 j = ne[j];之前, 那么在这里 i-n 和 i-j 都一样, 用哪个都行, 但是现在我们先写了 j = ne[j]; 所以这里只能是 i-n, 这里更推荐先写 j=ne[j], 因为打印并非所有题目都需要, 但是j = ne[j];却是不可少的 printf(\u0026#34;%d \u0026#34;, i - n); } } return 0; } 这里说一下不能无脑 j++两个 case:\ncase1: while 循环帮助我们把 j 回退到了 p 字符串中间位置, 因为 while 循环没有让 j++能能力, 所以需要我们主动加一\ncase2: while 循环帮我们把 j 回退到了 p 字符的起始位置, 那么说明$$p[1,i]$$此时没有公共前后缀了, 但是 while在 j==0 的时候就退出了, 那么这个时候我们还是需要手动预判字符是否匹配, 不匹配那么就可以让 j 一直处在起始位置而不需要移动, 直到能预判成功才移动\n推荐视频: https://www.bilibili.com/video/BV1Ag411o7US/?spm_id_from=333.337.search-card.all.click\u0026amp;vd_source=8852f187665680b3c355aff5e3c411dd\n题目: KMP字符串\n找出字符串中第一个匹配项的下标\n题外话 因为我们现在是从下标为 1 开始, 但是在一些时候我们会直接得到一个完整的数组, 这个时候可以使用std::copy(arr.begin(), arr.end(), targetArr+targetStartIndex) 来把数组的值复制到 p 数组或者 s 数组\narr 是我们一开始就有的数组, 在 c++中, 数组有 begin() end() 方法\nbegin()方法返回的是一个 iterator, 该 iterator 指向数组第一个元素 end()方法返回的是一个 iterator, 该 iterator 指向数组最后一个元素\n应用举例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { std::string s = \u0026#34;Hello, World!\u0026#34;; char ch[1000] = {0}; // 初始化为全0 int startIdx = 1; // 开始的索引位置 // 确保不会溢出数组的边界 if (startIdx + s.length() \u0026lt; sizeof(ch)) { std::copy(s.begin(), s.end(), ch + startIdx); } // 打印结果 std::cout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; std::endl; // 注意：如果 ch[startIdx-1] 不是 \u0026#39;\\0\u0026#39;，cout结果可能不正确, 但是在空间足够的情况下数组的值肯定是复制过去了 return 0; } 由于我们从索引 1 开始写入，而 char 数组的起始位置（索引 0）被初始化为零 (\\0)，所以 cout 在输出字符数组时会从第一个非零的字符开始，直到下一个零字符为止。这意味着虽然整个字符串被复制到了数组中，但是 std::cout 只会打印从索引 1 开始的字符串。如果这不是你想要的行为，你需要将数组的第一个元素设置为一个空字符（\u0026rsquo;\\0\u0026rsquo;），以便正确打印。\n","permalink":"https://paper.3kis.top/posts/tech/algorithm0101-twopointers/","summary":"双指针 双指针(Two pointers)有两大类 情况一: 两个指针指向两个不同的序列, 比如归并排序 情况二: 两个指针指向同一个序列, 这种出现的更多","title":"数据结构和算法01"},{"content":"项目目录如下\n1 2 3 4 5 6 7 8 9 10 myprj ├── app ├── bin │ └── compose.sh │ └── stop.sh ├── compose │ └── docker-compose.yml ├── mysql │ └── data 可按照下面的命令来创建上面的这个目录结构\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #!/bin/bash # 接收参数 project_name=${1:-myprj} service_name=${2:-mysql} data_dir_name=${3:-mysql} # 创建项目目录结构 mkdir -p \u0026#34;${project_name}\u0026#34;/{app,bin,compose,\u0026#34;${data_dir_name}\u0026#34;/data} \u0026amp;\u0026amp; \\ # 创建 compose.sh 文件 cat \u0026lt;\u0026lt; EOF \u0026gt; \u0026#34;${project_name}/bin/compose.sh\u0026#34; #!/bin/bash root=\\$(cd \\$(dirname \\$0); pwd -P) docker-compose -p ${service_name} -f \\${root}/../compose/docker-compose.yml \u0026#34;\\$@\u0026#34; EOF # 创建 stop.sh 文件 cat \u0026lt;\u0026lt; EOF \u0026gt; \u0026#34;${project_name}/bin/stop.sh\u0026#34; #!/bin/bash # 停止并移除所有由docker-compose up创建的容器 # docker-compose down # 停止容器而不移除它们 docker-compose -f \\$(cd \\$(dirname \\$0); pwd -P)/../compose/docker-compose.yml stop # 停止特定的服务，可以在stop命令后面加上服务的名称 # docker-compose stop myservice EOF # 设置 compose.sh 和 stop.sh 为可执行文件 chmod +x \u0026#34;${project_name}/bin/compose.sh\u0026#34; \u0026#34;${project_name}/bin/stop.sh\u0026#34; \u0026amp;\u0026amp; \\ # 创建 docker-compose.yml 文件 touch \u0026#34;${project_name}/compose/docker-compose.yml\u0026#34; 该脚本可以保存为一个文件，比如 create_project.sh。然后你可以赋予它执行权限并运行，传递相应的参数：\n1 2 chmod +x create_project.sh ./create_project.sh myprj mysql data myprj 是项目名称，mysql 是 docker-compose 中使用的服务名称，data 是数据库数据目录的名称。这些值将替换脚本中的相应占位符。如果没有提供参数，则会使用默认值（myprj、mysql 和 mysql）\ncompose.sh 内容如下\n1 2 3 4 5 6 7 8 9 10 11 12 #!/bin/bash root=$(cd `dirname $0`; dirname `pwd`) # exec \u0026#34;$@\u0026#34; 这行命令。$@ 是 shell 脚本获取参数的符号，这里获得的是所有传入脚本的参数，而 exec 是执行命令，直接执行这些参数。 # sudo ./bin/compose down ====\u0026gt; down表示关闭 service 并删除 container # sudo ./bin/compose up -d ====\u0026gt; up -d表示启动 container # -p 参数指定项目名称。在这个例子中，项目名称被设置为 mysql。Docker Compose 会使用这个名称作为容器、网络和卷名称的前缀，以便将它们与其他项目隔离开来 # -f 参数用来指定 docker-compose.yml 文件的位置。在这个例子中，文件位于当前目录下的 compose 子目录中 docker-compose -p mysql -f ${root}/compose/docker-compose.yml \u0026#34;$@\u0026#34; # 使用这个脚本的命令: sudo ./bin/compose.sh up -d docker-compose.yml内容如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 version: \u0026#34;3\u0026#34; services: mysql1: image: mysql:latest volumes: - ../mysql/data:/var/lib/mysql environment: MYSQL_ROOT_PASSWORD: password1 MYSQL_DATABASE: database MYSQL_USER: user1 MYSQL_PASSWORD: password1 ports: - 3306:3306 在命令行给compose.sh添加执行权限\n1 chmod +x ./bin/compose.sh 执行该脚本运行 container\n在 myproject 目录下执行\n1 sudo ./bin/compose.sh up -d ","permalink":"https://paper.3kis.top/posts/tech/docker-mysql/","summary":"项目目录如下 1 2 3 4 5 6 7 8 9 10 myprj ├── app ├── bin │ └── compose.sh │ └── stop.sh ├── compose │ └── docker-compose.yml ├── mysql │ └── data 可按照下面的命令来创建上面的这个目","title":"docker 运行 MySQL"},{"content":"什么是前缀和 对于一组数 a1, a2, a3, a4, a5\n其前缀和为 Si = a1 + a2 + .. + ai\n如何求前缀和 在其中 i 的初始下标为 1, 我们可以得到递推公式 $S_i = S_{(i-1)} + a[i]$\n让 i 从 1 开始且定义 S[0] = 0, 这是为了方便我们计算出指定区间的元素和\n前缀和有什么用 比如当我们计算区间[l,r]的所有数的和, 就可以直接 S[r] = S[l-1]\n现在要求 [1,10]之前的和, 就可以直接 S[10] - S[0]即可得解\n即 s[r]-s[l-1]\n为啥不直接 for 循环求[l, r] 因为如果我们有很多个 [l,r]区间要求, 那么就得来十次 for 循环, 而采用前缀和只需要一次从头到尾的 for 循环后面直接相减即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 const int N = 100010; int a[N], S[N]; int main(){ int m,n; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); S[i] = S[i-1] + a[i]; } for(int i = 0; i \u0026lt; m; i++){ int l, r; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;l, \u0026amp;r); printf(\u0026#34;%d\\n\u0026#34;, S[r]-S[l-1]); } return 0; } 例题: 前缀和\n二维前缀和 同理, 二维数组的前缀和也是每个 index 对应的 value 之和\n二维前缀和的作用? 求子矩阵的和\n现在我们要求 S33 和 S11 围起来的这块子矩阵的和, 那么可以根据前缀和求解.\n他等于 S33 - S31 - S13 + a00\n可以看到这个一维前缀和s[r]-s[l-1] 是类似的, 只不过最后要加上一块缺的角\n即: 求 [x1][y1]到 [x2][y2]的公式为 S[x2][y2] - S[x1-1][y2] - S[x2][y2-1] + a[x1-1][y1-1]\n构造二维前缀和 首先肯定要有原始数组矩阵, 这个原始数组最好有效元素都从 index=1 开始\n有了原始数组, 就可以从 1 开始构造了前缀和矩阵了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 const int N = 1010, M = 1010; int a[N][M]; int S[N][M]; int main(){ int n,m,q; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n,\u0026amp;m,\u0026amp;q); //构造原始数组矩阵 for(int i = 1; i\u0026lt;=n; i++) for(int j = 1; j \u0026lt;= m; j++) { scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i][j]); } //计算前缀和 for(int i = 1; i\u0026lt;=n; i++) for(int j = 1; j \u0026lt;= m; j++) { S[i][j] = S[i-1][j] + S[i][j-1] + a[i][j] - S[i-1][j-1]; } //求子矩阵的和 for(int i=0; i \u0026lt; q; i++){ int x1,y1,x2,y2; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;x1, \u0026amp;y1, \u0026amp;x2, \u0026amp;y2); int tmp = S[x2][y2] - S[x1 -1][y2] - S[x2][y1-1] + S[x1-1][y1-1]; printf(\u0026#34;%d\\n\u0026#34;, tmp); } return 0; } 例题: 子矩阵的和\n","permalink":"https://paper.3kis.top/posts/tech/algorithm1221-prefixsum/","summary":"什么是前缀和 对于一组数 a1, a2, a3, a4, a5 其前缀和为 Si = a1 + a2 + .. + ai 如何求前缀和 在其中 i 的初始下标为 1, 我们可以得到递推公式 $S_i = S_{(i-1)} + a[i]$ 让 i 从 1 开始且定","title":"前缀和"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; # 替换 USTC中科大 镜像 echo \u0026#39;export HOMEBREW_BREW_GIT_REMOTE=\u0026#34;https://mirrors.ustc.edu.cn/brew.git\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc source ~/.zshrc #使用 $USER 作为变量代替用户名避免用户名不同导致失败的情况 (echo; echo \u0026#39;eval \u0026#34;$(/opt/homebrew/bin/brew shellenv)\u0026#34;\u0026#39;) \u0026gt;\u0026gt; /Users/$USER/.zprofile eval \u0026#34;$(/opt/homebrew/bin/brew shellenv)\u0026#34; # used to edit .zshrc easily brew install --cask visual-studio-code # 隐藏shell用户名和主机名:这是对shell进行操作.所以对iterm2和terminal都能生效,所以不用担心在terminal里面执行无法看到iterm2的效果 echo \u0026#39;PROMPT=\u0026#34;%1~ %# \u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc source ~/.zshrc brew install golang maven brew install --cask alt-tab\tfeishu\tloop\tobsidian anki\tgoogle-chrome\tmaccy\torbstack\tswitchhosts\tvmware-fusion apifox\tiina\tmonitorcontrol\tpostman\ttelegram-desktop\twechat baidunetdisk\tmos\tqq\ttencent-lemon\twpsoffice-cn bartender\tkeka\tmotrix\tshottr\ttencent-meeting coconutbattery\tlocalsend\tsnipaste\tutools homebrew中科大源\nhttps://mirrors.ustc.edu.cn/help/brew.git.html\n如果一开始就无法从 github 拉去下载文件, 那么就通过上面中科大的链接中的镜像路径替换掉脚本的第一行\n注意, 我这里没有用brew 安装jdk, 原因有两个, 1是我需要安装多个版本的jdk, Homebrew提供的jdk不能满足我安装指定小版本 2是我希望通过下面jenv的方式管理jdk, 所以安装jdk请看下面的内容.\n要是懒得整jenv, 想直接用jdk, 那么可以brew install zulu@8\niterm2 or 其他插件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 brew install --cask iterm2 # 后续可使用iterm2 进行操作, 也可继续在 terminal 内操作 # 在 terminal 中打开 iterm2 #open -a iTerm # install oh-my-zsh sh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\u0026#34; cd ~/.oh-my-zsh/custom/plugins/ git clone https://github.com/zsh-users/zsh-autosuggestions cd ~/.oh-my-zsh/custom/plugins/ git clone https://github.com/zsh-users/zsh-syntax-highlighting.git code ~/.zshrc # 手动在 vscode 上修改plugin， 添加 zsh-syntax-highlighting和zsh-autosuggestions, zsh-syntax-highlighting一定要写在最后 简书:Mac中iTerm22+Oh My Zsh安装、配置和使用\n安装插件后再 .zshrc 中写好插件名(如下图):\niterm快捷键和我们习惯的mac快捷键不同, 比如command+ \u0026lt;- 就没法跳到行位, 所以可以调整他的快捷键\n参考链接\nhttps://juejin.cn/post/7133138258556354573\nChrome 暗黑模式 在浏览器地址栏写入 chrome://flags/#enable-force-dark 就能选择开启关闭或跟随系统主题了\n设置立即显示Dock（无动画）\n第一行设置开启 dock 隐藏, 第二行设置立即显示 dock, 第三行重启 dock 使得设置生效\n1 2 3 defaults write com.apple.dock autohide -bool true defaults write com.apple.dock autohide-time-modifier -float 0 killall Dock 其他内容 jdk下载并使用jenv进行多版本管理 在这个链接https://www.azul.com/downloads/?package=jdk#download-openjdk下载jdk, zulu的jdk支持javaFx的包, 感觉应该会比别的jdk全一点\nmac上自带了java虚拟机对应的jdk存放路径, 路径为/Library/Java/JavaVirtualMachines\n我们可以把jdk下载之后, 手动把jdk挪动到这个路径下\n参考链接 https://cloud.tencent.com/developer/article/1782923\nhttps://jasonkayzk.github.io/2023/12/17/%E4%BD%BF%E7%94%A8jenv%E7%AE%A1%E7%90%86jdk%E7%89%88%E6%9C%AC/\nhttps://juejin.cn/post/7060142839694852127\nbrew安装的软件 软件名 作用 alt-tab 像Windows一样可以切换窗口并且预览各个窗口内容, 解决mac切换窗口时只有软件图标的痛点 feishu loop 利用快捷键让窗口可以分成上下左右四个角或者半屏 obsidian anki google-chrome maccy 剪切板, 可以设置快键键位 command+shift+v orbstack 替代docker-desktop, 更轻量化 switchhosts 配置host, 避免每次都查host文件位置 vmware-fusion 虚拟机, 使用Linux系统 apifox iina 视频播放器 monitorcontrol 显示器控制亮度 postman telegram-desktop wechat baidunetdisk mos 控制鼠标和触控板的滑动方向互不影响 qq tencent-lemon 全局流量速率实时查看 wpsoffice-cn bartender 14寸mac必备的通知栏软件图标折叠工具 keka 压缩器 motrix 下载器 shottr 截屏软件, 自带OCR tencent-meeting coconutbattery 检测电池健康度 localsend 安卓和苹果之间互传 snipaste 截图工具, 缺少OCR功能 utools 一些在brew之外下载的软件 Intellij-idea GoLand DataGrip\n右键专业助手 为了解决在 Finder 中右键连文件都创建不了的缺陷😒\n长这样\n输入法控制 不再推荐该软件, 因为有一定概率导致屏幕出现小黑块\n为了解决某些软件自动把我的搜狗输入法切成系统原生 abc 输入法\n虽然可以通过 plist 等工具直接把 abc 输入法删除, 但是不确定删除之后进入系统安全模式时还能否正常使用键盘\n软件损坏解决 1 sudo xattr -r -c /Applications/LockedApp.app 然后打开软件还是会出现上图的提示, 这个时候要去设置\u0026ndash;\u0026ldquo;隐私和安全性\u0026rdquo;\u0026ndash;\u0026ldquo;打开\u0026rdquo; 这样就可以打开软件了\nbrew安装的软件说明 keka 解压缩\nmonitorcontrol 控制外接显示器亮度\niina 视频播放器\nmos 触控板与鼠标滑动逻辑分离\n一些还不错的mac配置文章 https://44maker.github.io/wiki/Mac/index.html\nhttps://appstorrent.ru/\nhomebrew 下载慢 参考这篇文章的方法二 https://developer.aliyun.com/article/1326823\n","permalink":"https://paper.3kis.top/posts/tech/newmac-init-config/","summary":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; # 替换 USTC中科大 镜像 echo \u0026#39;export HOMEBREW_BREW_GIT_REMOTE=\u0026#34;https://mirrors.ustc.edu.cn/brew.git\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc source ~/.zshrc #使用 $USER 作为变量代替用户名避免用","title":"快速配置新的macbook"},{"content":"Homebrew typora下载\n将下面的内容保存为typora.rb在你指定的目录下, 我一般会在 ~/code/homebrew-custom 下创建\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 cask \u0026#34;typora\u0026#34; do version \u0026#34;0.11.18\u0026#34; sha256 \u0026#34;cc8c9b07f4584f81b214d4a2cbc270cb1171d7262f0f7ffdd466f8b74b2da38e\u0026#34; # 原本为： url \u0026#34;https://www.typora.io/download/Typora-#{version}.dmg\u0026#34; 现在改为 https://download.typora.io/mac/Typora-0.11.18.dmg 多了mac这个path和具体的version url \u0026#34;https://download.typora.io/mac/Typora-0.11.18.dmg\u0026#34; name \u0026#34;Typora\u0026#34; desc \u0026#34;Configurable document editor that supports Markdown\u0026#34; homepage \u0026#34;https://typora.io/\u0026#34; livecheck do url \u0026#34;https://www.typora.io/download/dev_update.xml\u0026#34; strategy :page_match regex(/Typora-(\\d+(?:\\.\\d+)+)\\.dmg/i) end auto_updates true depends_on macos: \u0026#34;\u0026gt;= :high_sierra\u0026#34; app \u0026#34;Typora.app\u0026#34; zap trash: [ \u0026#34;~/Library/Application Support/abnerworks.Typora\u0026#34;, \u0026#34;~/Library/Application Support/com.apple.sharedfilelist/com.apple.LSSharedFileList.ApplicationRecentDocuments/abnerworks.typora.sfl*\u0026#34;, \u0026#34;~/Library/Application Support/Typora\u0026#34;, \u0026#34;~/Library/Caches/abnerworks.Typora\u0026#34;, \u0026#34;~/Library/Cookies/abnerworks.Typora.binarycookies\u0026#34;, \u0026#34;~/Library/Preferences/abnerworks.Typora.plist\u0026#34;, \u0026#34;~/Library/Saved Application State/abnerworks.Typora.savedState\u0026#34;, \u0026#34;~/Library/WebKit/abnerworks.Typora\u0026#34;, ] end 下载命令：\n1 brew install --cask ${typora.rb的绝对路径} 下面贴一个 bartender4 的 brew 脚本, 就不用去 github 找了\nbartender.rb\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 cask \u0026#34;bartender\u0026#34; do version \u0026#34;4.2.25\u0026#34; sha256 \u0026#34;7e594d4955808df139bc3aa4a408a8bacbfdb64e18970e843d381eadce487299\u0026#34; url \u0026#34;https://macbartender.com/B2/updates/#{version.major}-#{version.minor}-#{version.patch.rjust(1, \u0026#34;0\u0026#34;)}/Bartender%20#{version.major}.dmg\u0026#34;, referer: \u0026#34;https://www.macbartender.com\u0026#34; name \u0026#34;Bartender\u0026#34; desc \u0026#34;Menu bar icon organizer\u0026#34; homepage \u0026#34;https://www.macbartender.com/\u0026#34; livecheck do url \u0026#34;https://www.macbartender.com/B2/updates/AppcastB#{version.major}.xml\u0026#34; strategy :sparkle, \u0026amp;:short_version end auto_updates true depends_on macos: \u0026#34;\u0026gt;= :big_sur\u0026#34; app \u0026#34;Bartender #{version.major}.app\u0026#34; uninstall delete: [ \u0026#34;/Library/Audio/Plug-Ins/HAL/BartenderAudioPlugIn.plugin\u0026#34;, \u0026#34;/Library/PrivilegedHelperTools/com.surteesstudios.Bartender.BartenderInstallHelper\u0026#34;, \u0026#34;/Library/ScriptingAdditions/BartenderHelper.osax\u0026#34;, \u0026#34;/System/Library/ScriptingAdditions/BartenderSystemHelper.osax\u0026#34;, ], launchctl: \u0026#34;com.surteesstudios.Bartender.BartenderInstallHelper\u0026#34;, quit: \u0026#34;com.surteesstudios.Bartender\u0026#34; zap trash: [ \u0026#34;~/Library/Caches/com.surteesstudios.Bartender\u0026#34;, \u0026#34;~/Library/Cookies/com.surteesstudios.Bartender.binarycookies\u0026#34;, \u0026#34;~/Library/Preferences/com.surteesstudios.Bartender.plist\u0026#34;, ] end ","permalink":"https://paper.3kis.top/posts/tech/homebrew-install-typora/","summary":"Homebrew typora下载 将下面的内容保存为typora.rb在你指定的目录下, 我一般会在 ~/code/homebrew-custom 下创建 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25","title":"Homebrew安装旧版typora"},{"content":"MySQL 架构 从上往下, 从左往右是数据的流动顺序:\nConnetors: 一些连接 MySQL 的 client, 比如我们常用 jdbc.\nConnection Pool(MySQL 的网络模块): client 的连接在 Connection Pool 中进行统一的管理, 比如身份认证, 线程的复用, 连接数量限制.\n这一部分的 IO 操作模式是 BIO, 由于是 BIO, 所以能力较弱\nSQL Interface: sql 的接口, 会尝试查缓存, 查不到走 Parser\nParser: sql 解析, 知道我们要拿什么数据, 要处理什么数据\nOptimizer: 对复杂的 sql 进行优化\nCaches \u0026amp; Buffers: 如果能命中缓存, 可能就直接从缓存走了\nPluggable Storage Engines: 可插拔的组件, 组件可以使用内存, 索引 和管理存储空间\nFile System: 文件系统, 存储各种文件如日志文件(redo log, undo log 等等) , 索引文件\nEnterprise Management: 企业管理工具, 有备份, 回复, 复制, 等功能\n在上面的这些组成部分中, Pluggable Storage Engine 是可以替换的, 也是我们想要对 MySQL 拓展时能进行拓展的点\nMySQL 存储 MySQL 对于表的相关信息存储可分为共享模式和独占模式, 独占模式是默认的. 独占模式: 一个 database(schema) 中各个表的相关信息分开存放, 放在不同的文件里 共享模式: 一个 database(schema) 中所有表的信息放一个文件里.\n在独占模式下有以下几种文件:\n日志组文件: *.ib_logfile0, *.ib_logfile1 默认大小为 5M, ib 是 innnodb 的缩写 独占表空间文件: *.ibd 在独占模式下, 每个表都会用一个文件存储自己的信息, ibd 表示 innodb 的 data 表结构文件: *.frm 字符集和排序规则文件: db.opt opt 表示option binlog 二进制文件: 记录主数据库服务器 DDL 和 DML 的操作, 也就是记录对数据库本身的结构做的修改操作和对数据的修改操作 二进制日志索引文件: master-bin.index 通过设置innodb_file_per_table=OFF 即可改为共享模式\n在共享模式下:\n​\t一个 schema 的所有表空间文件内容和表结构文件内容会放到一个文件里, 这个共享表文件的名称为ibdata1\n从物理上和逻辑上理解独占模式和共享模式的区别(如下图): 在物理上, 我们认为一个MySQL数据库就是 MySQL运行的服务器, 里面管理着多个逻辑上的数据库(database 或者叫 schema), 也就是说一个物理的MySQL Server 的实例可以放多个逻辑数据库\n我们说MySQL Server 这个进程or 这个服务器 时指的是一个 MySQL实例.\n当我们说存取数据的基本单元的时候, 我们说的是逻辑的一个一个 schema\n每个 database(schema) 在MySQL 的数据文件夹下是一个单独的子文件夹, 里面存放里自己的表结构文件和表空间文件. 默认情况下(也就是独占模式 ), 每个表都会有自己的独占表空间文件和表结构文件\nMySQL 执行流程 简化版 先查询缓存, 如果缓存中存在对应的查询记录, 并且从上一次到这一次的时间段之内数据没有被修改过, 那么就直接把缓存结果返回.\n查不到缓存, 解析器对 sql 语句进行解析得到 一颗抽象语法树 AST, 交由预处理器预处理, 接下来优化器来进行优化判断什么方式是最优的(相当于我们打车, 得到几条打车路线, 这几条打车路线哪个最快? 接下来就要考虑那条路线是最优的), 得到他认为执行效率最高的方式(最优的路径)之后, 生成执行计划 , 将执行计划发送给引擎, 存储引擎按照执行计划的操作方式去查表, 查索引, 数据拼接,返回结果给调用方并存入缓存.\n详细版 从大的层次来看, 可以分成 Server 层和引擎层\n在 Server 层主要做了 \u0026ldquo;接受请求, 语句的解析, 执行计划的生成\u0026rdquo;, 过程如下:\nclient 发来一条 update 语句, 连接器首先获取到连接, 然后交给分析器, 分析器查询缓存, 如果存在缓存就直接返回, 否则交给优化器, 优化器生成执行计划, 然后让执行器去调用引擎层来执行\n在引擎层的流程为:\n写 undo log, 因为现在是对数据的更新操作, 涉及到事务(此处的事务是隐式的),所以要先写 undo log\nQ1: 如果没有手动开启事务的话, 还会写 undo log 吗\n​\t会, 即使用户没有显式地使用 START TRANSACTION 或 BEGIN 命令开始一个事务，InnoDB 会为每一个单独的 SQL 语句启\t动一个隐式事务，并且在语句执行完毕后立即进行提交\n找记录所在的目标页\n如果目标页在内存中, 直接修改内存 如果目标页不在内存中, 那么去我们的 file system 中读取记录然后拉到内存中在进行修改 写 redo log\n写 bin log\n提交事务\n后续步骤和图中一致\nQ\u0026amp;A\nQ1: 为什么要先写 undo log 再写别的 log 呢?\n​\t因为 undo log 是用来回滚的, 后续的过程比较长, 一旦发生了变动, 那么必须有一个 checkpoint 来进行回退, 所以最开始就得先\t写 undolog\n​\tredo log 是和事务深度绑定的, 如果我们的事务成功, 但是事务没来得及刷磁盘的数据块, 那么当我们恢复的时候, 还是\t会去\t执行 redo log 完成刷盘(redo log 用到的磁盘数据块和事务修改对应数据的磁盘数据块不是同一个数据块)\n​\tbin log 是用来主从复制的, 所以需要有binlog\nMySQL对 SQL 的执行顺序 前三步拿到我们需要的 table (from，on, join 找到需要的表，然后以指定的条件把他们关联在一起得到一个新的虚拟表），接下来对 table 中的数据进行过滤（对上一步拿到的大的虚拟表进行过滤，where 是根据直接条件进行过滤，group by 和 having 是分组之后的条件进行过滤），过滤完之后得到一个过滤结果，接下来考虑如何显示这些数据（因为过滤完之后的结果集可能有几十个字段，所以 select 决定我们显示哪些字段，order by 让我们知道以什么顺序来显示，limit 限制了显示的条数）\nmysql索引原理 ","permalink":"https://paper.3kis.top/posts/tech/mysql-notes/","summary":"MySQL 架构 从上往下, 从左往右是数据的流动顺序: Connetors: 一些连接 MySQL 的 client, 比如我们常用 jdbc. Connection Pool(MySQL 的网络模块): client 的连接在 Connection Pool 中进行统一的管理, 比如身份认证, 线程","title":"MySQL 学习笔记"},{"content":"Semaphore: 同一时间控制并发线程数. 比如⇒⇒我们对外提供了一个工具类, 这个工具类通过Semaphore限定了只有四个线程能获取到锁, 那么不管外界开启了多少个线程来调用我们的工具类, 始终只有四个线程能运行我们的工具类, 这就是通过Semaphore来控制\nCountDownLatch: CountDown表示”减少”, Latch表示”锁”, 所以就是从高往低来计数. 一个leader带5个小弟干活, 等五个小弟干完活了一起去吃饭, 那么leader就调用CountDownLatch的await()方法进入阻塞状态, 每个小弟执行完任务之后调用下CountDown()方法, 这样, 所有的小弟干完活之后leader就知道了, 然后就可以去吃饭.\nCyclicBarrier: 就像是一桌酒席, 两个人都到了await() 才能开席. 只有一个人到了await()那么是没法开席的\nFutureTask: 调用了FutureTask的 get 方法, 那么在没有拿到结果之前, 调用方(调用了 get 方法的线程) 会陷入阻塞状态\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 public class Work03 { public static void main(String[] args) { long start=System.currentTimeMillis(); // 在这里创建一个线程或线程池， // 异步执行 下面方法 int result = sum(); //这是得到的返回值 // 确保 拿到result 并输出 System.out.println(\u0026#34;异步计算结果为：\u0026#34;+result); System.out.println(\u0026#34;使用时间：\u0026#34;+ (System.currentTimeMillis()-start) + \u0026#34; ms\u0026#34;); // 然后退出main线程 } private static int sum() { return fibo(36); } private static int fibo(int a) { if ( a \u0026lt; 2) return 1; return fibo(a-1) + fibo(a-2); } } //方式一: Callable+FutureTask class Work0301 { public static void main(String[] args) { long start=System.currentTimeMillis(); // 在这里创建一个线程或线程池， // 异步执行 下面方法 int result = 0; //这是得到的返回值 FutureTask\u0026lt;Integer\u0026gt; integerFutureTask = new FutureTask\u0026lt;\u0026gt;(() -\u0026gt; { //如果在这里加上 sleep(1000), 那么 main 线程就会阻塞一会 return sum(); }); new Thread(integerFutureTask).start(); try { //如果没有异步线程去执行 task 的内容, 那么 get 就会一直阻塞, 通过阻塞来来确保能拿到 result result = integerFutureTask.get(); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { throw new RuntimeException(e); } // 确保 拿到result 并输出 System.out.println(\u0026#34;异步计算结果为：\u0026#34;+result); System.out.println(\u0026#34;使用时间：\u0026#34;+ (System.currentTimeMillis()-start) + \u0026#34; ms\u0026#34;); // 然后退出main线程 } private static int sum() { return fibo(36); } private static int fibo(int a) { if ( a \u0026lt; 2) return 1; return fibo(a-1) + fibo(a-2); } } //方式二: Semaphore class Work0302 { static int result = 0; //这是得到的返回值 public static void main(String[] args) { long start=System.currentTimeMillis(); // 在这里创建一个线程或线程池， // 异步执行 下面方法 Semaphore semaphore = new Semaphore(0); new Thread(() -\u0026gt; { result = sum(); semaphore.release(); }).start(); try { semaphore.acquire(); } catch (InterruptedException e) { e.printStackTrace(); } // 确保 拿到result 并输出 System.out.println(\u0026#34;异步计算结果为：\u0026#34;+result); System.out.println(\u0026#34;使用时间：\u0026#34;+ (System.currentTimeMillis()-start) + \u0026#34; ms\u0026#34;); // 然后退出main线程 } private static int sum() { return fibo(36); } private static int fibo(int a) { if ( a \u0026lt; 2) return 1; return fibo(a-1) + fibo(a-2); } } //方式三: CountdownLatch class Work0303 { static int result = 0; //这是得到的返回值 public static void main(String[] args) { long start=System.currentTimeMillis(); // 在这里创建一个线程或线程池， // 异步执行 下面方法 //CountdownLatch 就相当于是一个leader 等着await() 手下把活(异步线程的任务)干完了countdown(),然后去吃饭(干主线程自己的活) CountDownLatch countDownLatch = new CountDownLatch(1); new Thread(() -\u0026gt; { result = sum(); countDownLatch.countDown(); }).start(); try { countDownLatch.await(); } catch (InterruptedException e) { e.printStackTrace(); } // 确保 拿到result 并输出 System.out.println(\u0026#34;异步计算结果为：\u0026#34;+result); System.out.println(\u0026#34;使用时间：\u0026#34;+ (System.currentTimeMillis()-start) + \u0026#34; ms\u0026#34;); // 然后退出main线程 } private static int sum() { return fibo(36); } private static int fibo(int a) { if ( a \u0026lt; 2) return 1; return fibo(a-1) + fibo(a-2); } } //方式四: CyclicBarrier class Work0304 { static int result = 0; //这是得到的返回值 public static void main(String[] args) { long start=System.currentTimeMillis(); // 在这里创建一个线程或线程池， // 异步执行 下面方法 //CyclicBarrier就像是一桌酒席, 两个人都到了await() 才能开席. 只有一个人到了await()那么是没法开席的 CyclicBarrier cyclicBarrier = new CyclicBarrier(2, ()-\u0026gt; { System.out.println(String.format(\u0026#34;%s is running the action task\u0026#34;, Thread.currentThread().getName())); }); new Thread(() -\u0026gt; { result = sum(); try { cyclicBarrier.await(); } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { throw new RuntimeException(e); } //加上下面的 sleep, 那么肯定执行 action 的就是 main 线程了 try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } }, \u0026#34;myCustomThread\u0026#34;).start(); try { cyclicBarrier.await(); } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { throw new RuntimeException(e); } // 确保 拿到result 并输出 System.out.println(\u0026#34;异步计算结果为：\u0026#34;+result); System.out.println(\u0026#34;使用时间：\u0026#34;+ (System.currentTimeMillis()-start) + \u0026#34; ms\u0026#34;); // 然后退出main线程 } private static int sum() { return fibo(36); } private static int fibo(int a) { if ( a \u0026lt; 2) return 1; return fibo(a-1) + fibo(a-2); } } //其他的方法: 可以使用线程池+上面四种方法来满足需求. ","permalink":"https://paper.3kis.top/posts/tech/dayli-record1213/","summary":"Semaphore: 同一时间控制并发线程数. 比如⇒⇒我们对外提供了一个工具类, 这个工具类通过Semaphore限定了只有四个线程能获取到锁, 那么不管外界开启了","title":"Java随笔---多种方式拿到异步线程结果"},{"content":"考虑到下面的命令每次 push 都要写三次, 过于麻烦, 所以在 mac 中简化一下\n1 2 3 git add . git commit -m \u0026#34;new commit\u0026#34; git push 在命令行执行下面的命令:\n1 2 3 echo \u0026#34;\\n# 使用方式: 在命令行中写下 lazygit \\\u0026#34;My commit msg.\\\u0026#34; 然后\\\u0026#34;My commit msg.\\\u0026#34; 便会作为 commit 消息\\nfunction lazygit() {\\n\\tgit add .\\n\\tgit commit -a -m \\\u0026#34;\\$1\\\u0026#34;\\n\\tgit push\\n}\u0026#34; \u0026gt;\u0026gt; ~/.zshrc source ~/.zshrc (ps: 印象中 macos13开始就默认的是 zsh 作为 shell 了, 笔者的环境是zsh, 所以就直接 echo 到.zshrc 了, 如果有旧版本的 macos 也可以自己改为.bashrc)\n之后想要 push 新的 commit 到 remote repo 就可以直接\n1 lazygit \u0026#34;new commit\u0026#34; ","permalink":"https://paper.3kis.top/posts/tech/daylirecord1213/","summary":"考虑到下面的命令每次 push 都要写三次, 过于麻烦, 所以在 mac 中简化一下 1 2 3 git add . git commit -m \u0026#34;new commit\u0026#34; git push 在命令行执行下面的命令: 1 2 3 echo \u0026#34;\\n# 使用方式: 在命令行","title":"简化 git 命令"},{"content":"刷题顺序按照：https://leetcode.cn/studyplan/coding-interviews/\n本题解中标题是链接，会直接跳转到leetcode界面，如果想要跳转到页面指定位置，需要点击目录前的小数字\n剑指 Offer 05. 替换空格 关键点：替换字符串 方法一：正则表达式 \\s匹配空格\n时间复杂度O(nm), n代表输入字符串长度，m代表正则表达式长度\nString的replaceAll(regex, input)方法，方法返回一个处理的结果，要记得接收处理结果\n方法二：考虑String不可变特性，使用StringBuilder逐个添加字符\n时间复杂度O(n), n为输入字符串长度\n识别当前char是否是空格，是则追加%20到Stirngbuilder中，否则添加当前char到StringBuilder中\n剑指 Offer 67. 把字符串转换成整数 原思路：\n不足之处：无法判断 \u0026ldquo;+++\u0026rdquo; \u0026ldquo;+\u0026rdquo; \u0026ldquo;\u0026ndash;\u0026ldquo;之类的符号\n改进：\n使用了Character自带的isDigit()方法判断当前字符是否是一个int 符号位的判断由循环改成单次，避免了 +++ +-这种情况 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public int strToInt(String str) { if (str == null || str.length() == 0){ return 0; } int i = 0; int n = str.length(); long res = 0; char[] charArray = str.toCharArray(); int sign = 1; //去除空格 while (i \u0026lt; n \u0026amp;\u0026amp; charArray[i] == \u0026#39; \u0026#39;){ i++; } //首先需要判断下标是否会越过数组长度 //判断符号位是否存在，存在的话是什么,这里不用循环，就可以避免“+++”、“+-+”这种情况 if (i \u0026lt; n \u0026amp;\u0026amp; (charArray[i] == \u0026#39;+\u0026#39; || charArray[i] == \u0026#39;-\u0026#39;)) { sign = (charArray[i] == \u0026#39;-\u0026#39;) ? -1 : 1; i++; } //判断数字位，并且在添加下一个数之前判断是否溢出 while (i \u0026lt; n \u0026amp;\u0026amp; Character.isDigit(charArray[i])){ //res*10之后可能会越界导致数据溢出，造成结果不准确，所以一开始的res要用long类型 long tmp = res * 10 + charArray[i] - \u0026#39;0\u0026#39;; //判断是否会越界 //这里要带上符号位来比较大小 if (tmp * sign \u0026gt; Integer.MAX_VALUE){ return Integer.MAX_VALUE; }else if (tmp * sign \u0026lt; Integer.MIN_VALUE){ return Integer.MIN_VALUE; } //这里先不急着赋予符号位，因为给了符号之后就不好使用res * 10 + charArray[i] - \u0026#39;0\u0026#39;来得到下一个数了。所以res在函数结尾return的时候才带上符号位 res = tmp; i++; } //带上符号位 return (int)res*sign; } } 在解决这个问题时，我们可以考虑逐步分析题目要求，并制定相应的解决方案：\n首先，我们需要丢弃开头的空格字符。这可以通过迭代字符串，跳过空格字符来实现。\n接下来，我们需要处理符号位。如果第一个非空字符是正号或负号，我们需要记录符号位，并将指针向后移动一位。\n然后，我们需要处理数字字符。从当前位置开始，我们可以通过迭代字符串，判断字符是否是数字字符，并将其转换为对应的整数值。\n在处理数字字符的过程中，我们需要注意可能的溢出情况。因为题目要求假设环境只能存储32位大小的有符号整数，所以我们需要检查结果是否超出了这个范围。\n最后，我们将符号位乘以结果的整数值，并返回最终结果。\n这个解决方案的关键是理解题目的要求，并根据要求逐步实现对字符串的处理。需要注意的是，我们使用long类型来存储中间结果，以应对可能的溢出情况。并且，在最后返回结果时，需要进行强制类型转换为int类型。\n通过仔细阅读题目要求，将其转化为具体的解决方案，并使用逐步迭代的方式进行实现，可以帮助我们设计出符合要求的解决方案。\n剑指 Offer 35. 复杂链表的复制 原思路：\n​\t复制链表，所以每个节点都是新的\n​ 使用map记录每个节点和其相对位置，第一次遍历链表，把所有节点作为key全部放入map，value默认-1。\n​ 第二次遍历，对map中每个key指出对应的value作为顺序下标\n不足之处：无法顺序遍历每个节点，即使遍历了，也难以复制出新的节点\n解法：两次遍历，第一次map中存入旧节点作为key，新节点作为value；第二次将value中的节点建立联系，由于key和value的顺序在第一次遍历中已经确定，且key的相对顺序也被确定，所以可以方便的找到对应顺序的value\n要想到使用哈希表来复制复杂链表，可以按照以下思路进行分析：\n首先，我们要理解题目中对复杂链表的定义。复杂链表中的每个节点除了有一个next指针指向下一个节点，还有一个random指针指向链表中的任意节点或者null。\n我们可以考虑使用哈希表来辅助复制链表。哈希表可以将原节点和对应的新节点进行映射，以便在建立新链表的时候能够快速找到对应的节点。\n解决这个问题的关键是在复制过程中正确处理random指针的指向。由于random指针可能指向任意节点，我们需要保证在哈希表中能够找到对应的新节点。\n我们可以通过两次遍历链表来完成复制过程。第一次遍历时，我们创建新节点，并将原节点和新节点的映射关系存储到哈希表中。第二次遍历时，我们根据原节点的next和random指针，设置新节点的next和random指针。\n最后，返回新链表的头节点。\n通过按照题目要求的规则进行分析，并结合哈希表来辅助复制过程，可以想到使用哈希表来复制复杂链表的解决方案。\n在实际编码过程中，我们需要熟悉哈希表的使用，并合理设置节点映射关系。同时，需要注意处理边界情况，如空链表和random指针为null的情况。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public Node copyRandomList(Node head) { //这里判断条件不能有head.next==null，否则会导致下面对应的value节点不能正常生成 if (head == null) { return head; } Map\u0026lt;Node, Node\u0026gt; nodeMap = new HashMap\u0026lt;\u0026gt;(); Node p = head; //第一次遍历：复制节点值建立新节点，利用map映射使得新节点顺序和旧节点顺序一致， while (p != null){ Node newNode = new Node(p.val); nodeMap.put(p, newNode); p = p.next; } p = head; //第二次遍历: 建立新结点之间的关系,即：建立新节点的 next 和 random 指针 while (p != null){ //使用p作为旧链表的指针, 把p当成旧节点，这样我们就可以不通过map的key来知道旧节点的next和value了 Node newNode = nodeMap.get(p); newNode.next = nodeMap.get(p.next); newNode.random = nodeMap.get(p.random); p = p.next; } return nodeMap.get(head); // 返回新链表的头节点 } } 剑指 Offer 18. 删除链表的节点 思路：head为null直接返回head。使用虚拟头节点dummy连接原来的链表，方便head.val为目标值的时候删除head。使用pre指针始终作为前一个节点来辅助，cur指针指向当前节点，不断地遍历节点，如果cur.val为目标值，那么借助pre删除cur，直接返回整条链表。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public ListNode deleteNode(ListNode head, int val) { if (head == null) { return head; } ListNode dummy = new ListNode(-1); ListNode pre = dummy; pre.next = head; ListNode cur = dummy.next; while (cur != null) { if (cur.val == val) { pre.next = cur.next; return dummy.next; } cur = cur.next; pre = pre.next; } return dummy.next; } 剑指 Offer 52. 两个链表的第一个公共节点 直接上思路：两个指针p1、p2分别指向headA与headB，当p1走到null，让他从headB开始走，p2同理，然后第二次走就会相遇，相遇（两者相等）时直接返回。即使两个都走到null，那么也是相等的，也可以返回。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == headB) return headA; if (headA == null || headB == null){ return null; } ListNode pA = headA; ListNode pB = headB; while (pA != pB) { pB = pB.next; pA = pA.next; if (pA == pB) return pA; if (pA == null) { pA = headB; } if (pB == null) { pB = headA; } } return pA; } 剑指 Offer 58 - I. 翻转单词顺序 原思路：去除字符串前后空格 -\u0026gt; 创建list保存每一个单词(含标点符号), 创建StringBuilder方便逐个添加char成为单词，将s改成charArray便于遍历取值 -\u0026gt; 逐个遍历数组字符，如果遍历到了空格字符，则判断SB是否是空格或空串，如果不是空串或空格，那么就把SB存到list中，清空SB继续遍历。如果当前字符不是空格字符，那么直接加到SB当中 -\u0026gt; 遍历结束之后，考虑到最后一个单词的SB还没存进去，所以存进去之后清空SB -\u0026gt; 逆序遍历List，每次加上一个存入SB \u0026ndash;》返回时删除最后的空格再返回\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public String reverseWords(String s) { //删除前后的空格部分 s = s.trim(); List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); StringBuilder stringBuilder = new StringBuilder(); char[] charArray = s.toCharArray(); //开始读取单词部分 for (int i = 0; i \u0026lt; charArray.length; i++) { if (charArray[i] == \u0026#39; \u0026#39;) { //说明不存在空格或SB不是空字符串，是我们想要的要的SB String curStr = stringBuilder.toString(); //改成 if (curStr != \u0026#34;\u0026#34;) 也可以通过测试 if (curStr != \u0026#34; \u0026#34; \u0026amp;\u0026amp; curStr != \u0026#34;\u0026#34;) { list.add(curStr); stringBuilder.delete(0, stringBuilder.length()); } }else { stringBuilder.append(charArray[i]); } } if (stringBuilder.indexOf(\u0026#34; \u0026#34;) == -1) { list.add(stringBuilder.toString()); stringBuilder.delete(0, stringBuilder.length()); } for (int i = list.size() - 1; i \u0026gt;= 0; i--) { stringBuilder.append(list.get(i) + \u0026#34; \u0026#34;); } return stringBuilder.delete(stringBuilder.length() - 1, stringBuilder.length()).toString(); } } 其实也不需要判断是否是空格字符串，只需要判断空串也能达到目的\n代码更简洁的思路：双指针\n使用一个StringBuilder B，用来存储最终结果。使用trim()删除函数接收到的字符串的前后空格得到新的s \u0026ndash;》对s从后往前遍历，定义两个指针i j，遍历开始前都指向s的最后一个字符，让i往前走，遇到第一个空格停下，使用subString(i+1，j)截取到这个单词加上空格存到B中 \u0026ndash;》i继续跳过空格且不超过s的头部字符，直到遇到字符停下来，让j跳到i+1的位置，继续遍历 \u0026ndash;》 遍历结束后，再使用trim()删除前后的空格返回结果\n双指针细节：\n对s进行清空前后空白字符的操作\n先让left指针移动到s中空白区，也就是 while(left\u0026gt;=0\u0026amp;\u0026amp;s.charAt(left)!=' ')\n存储下此时left和right之间的字符串\n接下来让left指针移动到s中非空白区，也就是while(left\u0026gt;=0\u0026amp;\u0026amp;s.charAt(left)==' ')\n修改right指针的位置，让他到达left指针后面，也就是空白区的第一个位置\n循环继续\n上面中的第2步和第4步使得left指针能在s中的字符区和空白区进行移动，并且保证了先走出字符区，再走出空白区\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public String reverseWords(String s) { /* \u0026#34;the sky is blue\u0026#34; 字符区[空白区]字符区[空白区]字符区[空白区]字符区 */ int left = s.length() - 1; int right = left + 1; StringBuilder sb = new StringBuilder(); //trim保证了left指针一开始就是在字符区 s = s.trim(); while (left \u0026gt;= 0) { //先让left指针移动到空白区，使得left和right能包裹住这片字符 //只要移动了left，一定要保证不会越界，当left走到第一个位置的时候，还会执行left--，这就会导致越界 while (left \u0026gt;= 0 \u0026amp;\u0026amp; s.charAt(left) != \u0026#39; \u0026#39;){ left--; } //情况一：此时left走到了空白区的最后一个位置, 我们把字符区给截取下来 //情况二：此时left为-1，越界，我们也可以截取下来 sb.append(s.substring(left+1, right)); sb.append(\u0026#34; \u0026#34;); //接下来让left指针走出空白区 while (left \u0026gt;= 0 \u0026amp;\u0026amp; s.charAt(left) == \u0026#39; \u0026#39;) { left--; } //现在left指针走到了字符区，修改right指针的位置，重复循环 right = left + 1; } return sb.toString().trim(); } 剑指 Offer 30. 包含min函数的栈 易错点：再push的时候条件要搞清楚，要满足两个条件，①min队列为空时可直接加入 ②min队列最小值大于等于当前push的数字时，可直接加入min\n如果没考虑等于最小值也能入最小栈的情况，就可能把push部分写成：\n1 2 3 4 5 6 if (min.size() != 0){ int tmp = min.peekLast(); min.addLast(tmp \u0026gt;= x ? x : tmp); }else { min.addLast(x); } 下面是通过代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class MinStack { Deque\u0026lt;Integer\u0026gt; deque; Deque\u0026lt;Integer\u0026gt; min; /** initialize your data structure here. */ public MinStack() { deque = new ArrayDeque(); min = new ArrayDeque(); } public void push(int x) { deque.addLast(x); if (min.size() == 0 || min.peekLast() \u0026gt;= x){ min.addLast(x); } } public void pop() { int x = deque.pollLast(); if (x == min.peekLast()) { min.pollLast(); } } public int top() { return deque.peekLast(); } public int min() { return min.peekLast(); } } 剑指 Offer 59 - II. 队列的最大值 错误的push思路：\n1 2 3 4 5 6 7 8 //添加大于队列中的元素到max队列中，这里的逻辑有问题，如果总是添加了大的到最前面，那么无法判定是否第一个是最大的 //所以这里的思路是有问题的 public void push_back(int value) { deque.addLast(value); if (max.size() == 0 || max.peekLast() \u0026lt;= value) { max.addFirst(value); } } 正确的思路：对于将要添加的元素x，从max的最后一个元素开始向前逐一比对判断，如果x大于当前元素，则直接删掉（因为此时x在主队列中肯定是最新的，根据队列先进先出的特性，所以旧的那些可以不要）。\n等到把所有比x小的都删除，结束循环，将x添加到max中。\n改进后的代码：\n1 2 3 4 5 6 7 public void push_back(int value) { deque.addLast(value); while (!max.isEmpty() \u0026amp;\u0026amp; max.peekLast() \u0026lt; value){ max.pollLast(); } max.addLast(value); } 完整代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class MaxQueue { Deque\u0026lt;Integer\u0026gt; deque; Deque\u0026lt;Integer\u0026gt; max; public MaxQueue() { deque = new ArrayDeque\u0026lt;\u0026gt;(); max = new ArrayDeque\u0026lt;\u0026gt;(); } public int max_value() { return max.size() == 0 ? -1 : max.peekFirst(); } public void push_back(int value) { deque.addLast(value); //要保留能和value相等的元素，所以判断条件里面不能写等于 while (!max.isEmpty() \u0026amp;\u0026amp; max.peekLast() \u0026lt; value){ max.pollLast(); } max.addLast(value); } public int pop_front() { if (deque.size() == 0) return -1; int res = deque.pollFirst(); if (res == max.peekFirst()) { max.pollFirst(); } return res; } } 剑指 Offer 29. 顺时针打印矩阵 关键点：\n①Java二维数组的行数直接使用matirx.length得到\n②使用上边界、下边界、左边界、右边界能很好的通过边界来帮助我们对这个矩阵进行遍历\n③使用从0开始的下标index作为结果数组的下标，每遍历一个值都自增\n思路：要按照顺时针顺序打印矩阵的元素，可以使用模拟的方法。\n具体步骤如下：\n初始化四个边界变量：left、right、top、bottom，分别表示当前矩阵的左边界、右边界、上边界和下边界。\n初始化结果列表 result 用于存储按顺序打印的元素。\n进行循环，直到左边界大于右边界或者上边界大于下边界为止：\n从左到右打印当前上边界的元素，将它们添加到 result 列表中。打印完后，上边界 top 加1。\n从上到下打印当前右边界的元素，将它们添加到 result 列表中。打印完后，右边界 right 减1。\n如果上边界 top 小于等于下边界 bottom，保证下边界是没被遍历过的，然后从右到左打印当前下边界的元素，将它们添加到 result 列表中。打印完后，下边界 bottom 减1。\n如果左边界 left 小于等于右边界 right，保证左边界是没被遍历过的，然后从下到上打印当前左边界的元素，将它们添加到 result 列表中。打印完后，左边界 left 加1。\n返回结果列表 result。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public int[] spiralOrder(int[][] matrix) { int rowCount = matrix.length; if (matrix == null || rowCount == 0) return new int[]{}; int columnCount = matrix[0].length; int left = 0, right = columnCount - 1, top = 0, buttom = rowCount - 1; int[] res = new int[rowCount * columnCount]; int index = 0; while (left \u0026lt;= right \u0026amp;\u0026amp; top \u0026lt;= buttom){ //从左到右 for (int i = left; i \u0026lt;= right; i++) { res[index++] = matrix[top][i]; } top++; //从上往下 for (int i = top; i \u0026lt;= buttom; i++) { res[index++] = matrix[i][right]; } right--; //从右往左 if (top \u0026lt;= buttom){ for (int i = right; i \u0026gt;= left; i--) { res[index++] = matrix[buttom][i]; } buttom--; } //从下往上 if (left \u0026lt;= right){ for (int i = buttom; i \u0026gt;= top; i--) { res[index++] = matrix[i][left]; } left++; } } return res; } } 建议多做一两遍~~\n剑指 Offer 31. 栈的压入、弹出序列 这题好有意思~~\n看完题解后才有的思路\n思路：\n①建立一个辅助栈，然后遍历pop数组中每个元素。\n② 为push列表建立一个下标index\n③ a. 如果栈顶元素和当前遍历元素不相等，那么加入push数组中的元素到栈中，index自增，继续判断栈顶元素\n​ b. 如果栈顶元素和当前遍历元素相等，那么弹出栈顶元素，继续遍历pop数组\n④如果最终能将栈中的元素全部弹出，说明这个序列时正确的，此时stack为空\n定义一个辅助栈，用于模拟压栈和弹出的过程。 遍历弹出序列，依次判断每个元素是否与辅助栈的栈顶元素相同。 如果相同，则说明当前元素是下一个要弹出的元素，可以将辅助栈的栈顶元素弹出。 如果不相同，则将压栈序列中还未入栈的元素依次入栈，直到找到与当前元素相同的元素为止。 如果最后辅助栈为空，说明弹出序列是压栈序列的一个合法弹出序列；否则，弹出序列不是压栈序列的一个合法弹出序列。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public boolean validateStackSequences(int[] pushed, int[] popped) { Deque\u0026lt;Integer\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); int pushIndex = 0; for (int curPop : popped) { //条件应该是栈为空时必成成立，栈顶元素和当前遍历元素不相等时必成立 while (stack.isEmpty() || stack.peekLast() != curPop) { if (pushIndex \u0026gt;= pushed.length) { return false; } stack.addLast(pushed[pushIndex]); pushIndex++; } //此时栈不为空且栈顶元素和当前遍历的值相等，那么弹出栈顶元素，让下标移动； stack.pollLast(); //由于在循环中，进行了下标自增之后才判断栈顶元素是否和遍历元素是否相等，所以pushindex比栈顶元素在push数组中的位置更靠后，此处就不需要在自增了 //pushIndex++; } return stack.isEmpty(); } } 剑指 Offer 04. 二维数组中的查找 类似二分的思想\n思路：从矩阵的第一行最后一个元素开始查找 \u0026ndash;》当前元素左边的都比他小，下面都比他大（二分的体现） \u0026ndash;》 如果当前元素比target大，那么往下走，否则往左走 \u0026ndash;》 循环终止条件时行指针不能大于等于行总数，列指针不能小于0 \u0026ndash;》如果循环之后没找到，那么返回false\n时间复杂度O(m+n), m为矩阵行数，n为列数，耗时最长情况是target在最后一行的第一个，此时需要完整的走完一列一行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public boolean findNumberIn2DArray(int[][] matrix, int target) { int rowCount = matrix.length; if (matrix == null || rowCount == 0){ return false; } int columnCount = matrix[0].length; int row = 0; // 指针row指向第一行 int column = columnCount - 1; // 指针col指向最后一列 while (row \u0026lt; rowCount \u0026amp;\u0026amp; column \u0026gt;= 0){ if (matrix[row][column] == target) { return true; }else if (matrix[row][column] \u0026gt; target) { //说明下面的行只会更大，那么我们后面只会在这一行不断地缩小column就能找到答案 column--; }else { //说明我们需要走到下一行更大的数字中去 row++; } } return false; } } 2023/0706 剑指 Offer 50. 第一个只出现一次的字符 稍微容易出错的地方：第二次遍历的应该还是字符串而不是int数组，因为只有原字符串的顺序才是合理的字符顺序，如果按照int数组的顺序遍历，遍历出来的是字母表中的第一个次数为一的字符而不是字符串中第一个次数为一的字符\n思路：\n使用int数组来记录次数，数组的下标为任一小写字符到字符a的距离，值为出现的次数 \u0026ndash;》对字符串遍历，对当前字符对应的数组中的位置上的值自增 \u0026ndash;》第一次遍历结束，字符串中所有的数字都有了出现的次数，对字符串进行第二次遍历，根据字符串中字符的顺序找到数组中次数为一的元素，此时字符串中的对应字符就是第一个次数为1的字符\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public char firstUniqChar(String s) { if (s == null || s.length() == 0) { return \u0026#39; \u0026#39;; } int[] arr = new int[26]; Arrays.fill(arr, 0); char[] chars = s.toCharArray(); for (char ch : chars) { arr[ch - \u0026#39;a\u0026#39;]++; } for (char ch : chars) { if (arr[ch - \u0026#39;a\u0026#39;] == 1) { return ch; } } return \u0026#39; \u0026#39;; } } 剑指 Offer 32 - III. 从上到下打印二叉树 III 题目：请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。\n这题有一个很容易错的点：加入节点到队列的时候，是否需要根据当前层的层数判断加入节点的顺序？\n不需要\n只需要根据当前层数来控制加入的值应从队列前面加还是后面加。中间结果用队列来存，而不像其他的层序打印树的题一样用list存了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { if (root == null) { return new ArrayList\u0026lt;\u0026gt;(); } Deque\u0026lt;TreeNode\u0026gt; nodes = new ArrayDeque\u0026lt;\u0026gt;(); Deque\u0026lt;Integer\u0026gt; resSubList = new ArrayDeque\u0026lt;\u0026gt;(); List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); nodes.add(root); int level = 1; while (!nodes.isEmpty()){ int size = nodes.size(); for (int i = 0; i \u0026lt; size; i++) { TreeNode tempNode = nodes.pollFirst(); if (tempNode.left != null ) { nodes.add(tempNode.left); } if (tempNode.right != null) { nodes.add(tempNode.right); } //奇数层，按顺序加入 if (level % 2 == 1) { resSubList.addLast(tempNode.val); }else { resSubList.addFirst(tempNode.val); } } res.add(new ArrayList\u0026lt;\u0026gt;(resSubList)); resSubList.clear(); level++; } return res; } } 2023/0708 剑指 Offer 26. 树的子结构 多写几次熟悉熟悉\n1 2 3 题目：输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构) B是A的子结构， 即 A中有出现和B相同的结构和节点值。 容易忽略的点：B可以是A的中间一部分结构，而不需要满足是到某个非叶子节点到叶子节点的结构\n思路：目前仅有的函数是判断是否为子结构，但是这能让我们直接判断出来吗？显然是不行的，判断是否为子结构，就必须要去判断某个部分是否相等，所以我们应该单独写一个函数判断两棵树是否相等，我们将函数定义为boolean isSameTree(TreeNode A, TreeNode B)\n对于isSameTree函数，我们想想什么时候函数应该返回true，什么时候返回false\n如果我们要让函数返回false，那么就应该判断树的每一个节点是否都相等，如果不相等，那么就应该返回false。\n那么不相等有什么情况呢：1. A的节点此时为null了，那么就不行了 2. A的val与B的val不相等。\n上述两种情况就是false的情况。\n那么什么时候返回true呢？我们现在要判断这两个树是否相等，显然当B为null的时候，说明B之前的节点都能顺利走完了，所以到B为null的时候整颗树B都已经校验完了，此时应该返回null。\n当我们确定了返回true、false的条件之后，还需要考虑经过了判断条件之后怎么继续进行下一步，当前经过判断条件之后，我们把当前节点确认了，那么接下来就应该确认这两个节点的左右节点，所以我们给他们的左右节点做一个递归调用，将结果\u0026amp;\u0026amp;起来。这就完成了整个boolean isSameTree(TreeNode A, TreeNode B)函数的逻辑\n接下来考虑如何在isSubStruct这个函数里面调用这个函数\n对于isSubStruct，如果B为null，那么肯定返回false。\n接下来就要考虑A的左子树和B是否能成为子结构 或者 A的左子树和B是否能成为子结构 或者 A本身是否和B同\n这三个条件只要有一个满足，即可让整个函数返回true\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public boolean isSubStructure(TreeNode A, TreeNode B) { //自己调用自己时的终止条件或直接判断题目的输入参数是否满足要求 if (A == null || B == null){ return false; } return isSameStruct(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B); } private boolean isSameStruct(TreeNode A, TreeNode B) { //自己调用自己时的终止条件 if (B == null) { return true; } //自己调用自己时的终止条件 if(A == null || A.val != B.val) { return false; } return isSameStruct(A.left, B.left) \u0026amp;\u0026amp; isSameStruct(A.right, B.right); } } 剑指 Offer 27. 二叉树的镜像 思路：利用递归，终止条件为输入的节点为null，对于每一个节点，我们暂存其左子树，然后给左子树赋值整理好的镜像右子树，然后给该节点的右子树赋值整理好的镜像左子树\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public TreeNode mirrorTree(TreeNode root) { if(root == null) return root; TreeNode tmp = root.left; //把整理好的镜像右子树直接赋给左子树 root.left = mirrorTree(root.right); //把整理好的暂存镜像左子树直接赋给右子树 root.right = mirrorTree(tmp); return root; } } 剑指 Offer 28. 对称的二叉树 思路：对于输入的节点，如果节点为null，则返回true，否则使用函数recur，当前节点的左子树和右子树作为参数，获取函数返回值进行返回 \u0026ndash;》\n在recur中，\n​\t如果接受的两个节点有一个为null，则返回false\n​\t如果接受的两个节点的值不同，则返回false\n​\t如果接收到的两个节点都为null，说明前面的层次都通过了，来到了叶子节点的子节点，此时返回true\n递归调用recur，接收到的L、R节点，L的左子树和R的右子树作为参数、L的右子树和R的左子树作为参数。将调用结果 \u0026amp;\u0026amp; 再作为返回值返回\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public boolean isSymmetric(TreeNode root) { return root == null ? true : recur(root.left, root.right); } private boolean recur(TreeNode left, TreeNode right) { if (left == null \u0026amp;\u0026amp; right != null) return false; if (left != null \u0026amp;\u0026amp; right == null) return false; if (left == null \u0026amp;\u0026amp; right == null) return true; if (left.val != right.val) return false; return recur(left.left, right.right) \u0026amp;\u0026amp; recur(left.right, right.left); } } 2023/0709 剑指 Offer 12. 矩阵中的路径 题目：\n思路：这道题应该使用回溯算法，将矩阵中的每一个字符作为路径的开始，进行回溯。\n确定递归的参数：\n矩阵board：有了它才能知道当前的字符 行指针i 列指针j 目标字符串word 指向目标字符串当前的字符使用的索引wordIndex 当前位置是否已被其他路径访问的visited[][]数组 递归终止的条件：\n返回true时的条件：当字符串的下标的大小等于字符串的长度，则返回true 返回false的条件：行指针越界、列指针越界、当前指向的字符不相等、当前位置已经被其他路径访问过 进入下一层前对于参数的处理：\n将visited数组中对应位置标记为true 由于有四个方向，因此进入下一层要进入四次，每次只修改行或列 下一层处理完之后的结果：\n如果下一层处理之后的结果为true，则直接返回true 否则，标记当前的visited位置为false，当前层返回false； 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Solution { public boolean exist(char[][] board, String word) { if (board == null || board.length == 0) return false; int maxRow = board.length; int maxColumn = board[0].length; boolean[][] visited = new boolean[maxRow][maxColumn]; for (int i = 0; i \u0026lt; maxRow; i++) { for (int j = 0; j \u0026lt; maxColumn; j++) { if (dfs(board, i, j, 0, word, visited)) { return true; } } } return false; } private boolean dfs(char[][] board, int i, int j, int wordIndex, String word, boolean[][] visited) { //每次递归调用 dfs 时，index 参数表示当前正在匹配的 word 中的字符索引。 //如果能使得这一步的判断条件为true，那么表示前面的都已经匹配了，现在是最后一步 //当 index 的值等于 word.length() 时，说明已经匹配完整个 word 字符串，找到了符合条件的路径，可以返回 true。 if (wordIndex == word.length()) return true; //这里是递归终止的第二种情况：失败 //如果当前的下标越界、当前字符不相等，那么就可以停止这一条路径的遍历 //如果当前位置已经被访问过，那么说明其他路径已经把这一个位置走了，我这条路径的下一步就不用走这个位置了 if (i \u0026lt; 0 || i \u0026gt;= board.length || j \u0026lt; 0 || j \u0026gt;= board[0].length || board[i][j] != word.charAt(wordIndex) || visited[i][j]) { return false; } //没越界、字符相等、这个位置没被其他路径访问过，那么我就得把这个路径给标记成已访问 visited[i][j] = true; if (dfs(board, i+1, j, wordIndex+1, word, visited) || dfs(board, i, j+1, wordIndex+1, word, visited) || dfs(board, i-1, j, wordIndex+1, word, visited) || dfs(board, i, j-1, wordIndex+1, word, visited)) { return true; } //我这条路径已经走完了，并且保证以指定初始起点开始遍历，没法得到正确结果，所以我应该把visited数组中对应的位置标记为false //这样，当初始起点不同的时候，别的起点才能正常遍历他们自己的路径 //同时，也可以保证走到我这一步的起点的其他路径能正常访问 visited[i][j] = false; return false; } } 剑指 Offer 13. 机器人的运动范围 这题debug了五六次才通过。\n思路：这道题用的不是回溯，是搜索，所以不需要对visited数组做清除标记。用一个全局变量res记录能走的格子 \u0026ndash;》\n递归需要的参数：\nrow：当前走到的行 column：当前走到的列 m：最大行数 n：最大列数 k：数位和最大值 visited[][]: 格子是否被访问 递归终止条件：\n数位和大于k 下标越界 当前单元格被访问 进入下一层前需要做的处理：\n将当前单元格标记为true res++ ，这里只需要一个res就能记录所有的答案，因为递归终止条件保证了我们不会走到其他路径走过的单元格，同时visited数组不会清除已经走过的标记，所以当前单元格标记为true之后，res++是合理的 进入下一层需要修改的参数：\n行+1 or 行-1 or 列+1 or 列-1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { int res = 0; public int movingCount(int m, int n, int k) { boolean[][] visited = new boolean[m][n]; dfs(0, 0, m, n, k, visited); return res; } private void dfs(int row, int column, int m, int n, int k, boolean[][] visited) { //计算数位和 int count = 0; int tempRow = row; while (tempRow != 0){ count = count + tempRow % 10; tempRow /= 10; } int tempColumn = column; while (tempColumn != 0){ count = count + tempColumn % 10; tempColumn /= 10; } //递归终止条件 if (row \u0026lt; 0 || row \u0026gt;= m || column \u0026lt; 0 || column \u0026gt;= n || count \u0026gt; k || visited[row][column]){ return; } //标记当前单元格已走过 visited[row][column] = true; //能走的单元格数量+1 res++; //走下一个格子 dfs(row+1, column, m, n, k, visited); dfs(row - 1, column, m, n, k, visited); dfs(row, column+1, m, n, k, visited); dfs(row, column-1, m, n, k, visited); } } tip：计算数位和可以单独抽取出来作为一个方法来进行调用，因为计算行、列的数位和过程是一样的，所以可以抽取\n这里贴一个不使用全局变量，而是使用递归返回值作为答案的代码。\n这个代码和我的代码的不同之处在于：\n终止条件触发时，返回0，标志着现在这个单元格不能走，算成0个单元格 返回值是 当前单元格+后面能走的所有单元格之和 , 这一点很关键，是从当前单元格之后所有能走的单元格数量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class MovingCount { public int movingCount(int m, int n, int k) { boolean[][] visited = new boolean[m][n]; return dfs(0, 0, m, n, k, visited); } private int dfs(int i, int j, int m, int n, int k, boolean[][] visited) { if (i \u0026lt; 0 || i \u0026gt;= m || j \u0026lt; 0 || j \u0026gt;= n || visited[i][j] || getDigitSum(i) + getDigitSum(j) \u0026gt; k) { return 0; } visited[i][j] = true; return 1 + dfs(i - 1, j, m, n, k, visited) + dfs(i + 1, j, m, n, k, visited) + dfs(i, j - 1, m, n, k, visited) + dfs(i, j + 1, m, n, k, visited); } private int getDigitSum(int num) { int sum = 0; while (num \u0026gt; 0) { sum += num % 10; num /= 10; } return sum; } } 2023/0711 剑指 Offer 34. 二叉树中和为某一值的路径 原失败思路：\n递归终止条件：当前节点为null，同时如果当前累加值为target，则添加到res中\n进入下一层前的处理：curVal加上当前节点的值，list存入当前节点\n进入下一层的参数：最后的list结果、当前累加值curVal、目标值target、存储了路径上节点的list pathSum\n回溯处理：从pathSum中删除当前节点\n失败原因：一个叶子节点有两个null子节点，如果该条路径之和等于target，那么由于添加逻辑写在递归终止中，所以两个null节点会导致路径加了两次到res中\n改进：\n终止节点中不做添加正确路径到最后的list中 进入下一层前的处理改为：判断当前节点是否是叶子节点（left和right同时为空）\u0026amp;\u0026amp; curVal加上当前值之后是否与target相同 ，如果为true，那么直接在叶子节点这一层加入路径 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; pathSum(TreeNode root, int target) { if (root == null) return new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; pathSum = new ArrayList\u0026lt;\u0026gt;(); reverseToSum(res, root, target, 0, pathSum); return res; } private void reverseToSum(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, TreeNode root, int target, int curVal, List\u0026lt;Integer\u0026gt; pathSum) { if (root == null) { return; } curVal += root.val; pathSum.add(root.val); if (curVal == target \u0026amp;\u0026amp; root.left == null \u0026amp;\u0026amp; root.right == null){ res.add(new ArrayList\u0026lt;\u0026gt;(pathSum)); } reverseToSum(res, root.left, target, curVal, pathSum); reverseToSum(res, root.right, target, curVal, pathSum); pathSum.remove(pathSum.size() - 1); } } 2023/0712 剑指 Offer 36. 二叉搜索树与双向链表 这题最开始没看清楚是二叉搜索树，然后写了一个针对所有二叉树的算法，beats 2%左右😂\n后来发现是二叉搜索树之后，根据面经和题目要求还想了很久\n由于题目指定是二叉搜索树，所以按照中序遍历的顺序得到的节点顺序就是题目要求的链表元素的相对顺序\n保持中序遍历的顺序很容易理解和实现，难点在于在当前节点怎么进行处理\n思路：定义两个全局Node变量pre，head。pre负责始终指向前继节点、head负责指向链表开始节点\n对于当前节点，我们要做三件事：\n让当前节点的左指针指向pre 判断pre是否为null，如果为null，则说明当前节点是第一个节点，让head指向当前节点；如果不为null，那么让pre的右指针指向前继节点 \u0026mdash;\u0026ndash; 截止到第二部，已将完成了两个节点之间的互相指向 让pre移动到当前节点，pre=currentNode 结束遍历后，此时pre会指向链表中最后一个节点、head会指向第一个节点，我们还需要让他们相互指向，最后再返回head\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { Node pre, head; public Node treeToDoublyList(Node root) { if (root == null) return root; traverseInOrder(root); //当我们完成中序遍历之后，pre会出现在链表的最后一个元素，head会指向第一个元素，我们现在要给 //这两个元素互相指向 head.left = pre; pre.right = head; return head; } private void traverseInOrder(Node root) { if (root == null) return; traverseInOrder(root.left); //在当前节点应做的处理： //我们先把cur拿出来, 不管当前pre是否有值，当前节点的左指针都应该指向pre root.left = pre; //如果pre不为null，那么让pre的右指针指向当前节点 if (pre != null) { pre.right = root; }else { //否则，说明当前节点是第一个节点，应该让head也指向这个节点 head = root; } //pre此时完成了右指针的指向任务，应该移动到当前节点了 pre = root; traverseInOrder(root.right); } } 剑指 Offer 54. 二叉搜索树的第k大节点 二叉搜索树，按照正常中序遍历，肯定不知道啥时候出现第k大的节点，所以最容易想到的解法就是中序遍历这一个二叉搜索数，每次遍历的时候将遍历到的节点加入到list中。当我们遍历完之后，此时list中拥有所有的节点，要找到第K大的节点，则可以get(list.size()-k)\n由于list在添加节点过程中会涉及到一个扩容的过程，所以它可能使得整个的效率非常的低下，那么这时候我们就需要想办法去改进的方法，就是我们将中序遍历给它反过来。正常中序遍历是先遍历左子树，然后遍历根节点，再遍历右子树，现在我们先遍历右子树，在遍历中间节点，最后遍历左子树。这样的话我们就得到一个从大到小的序列。\n接下来还需要考虑：在这个遍历过程中，我们怎么样去判断当前这个节点的值是否是我们需要的呢？\n那么这时候我们就需要一个全局变量z，在每一次对当前节点处理的时候，我们将这个全局变量Z-1, 如果减1之后它的值等于0，就说明此时就是我们需要找的第 K大的节点，然后这个时候我们要保存这个节点值，保存节点的方法就是维护第二个全局变量result，我们将这个第K大的节点的值赋值给result，后面即使你再遍历其他节点，也不会影响res的值，因为我K是一个全局变量，所以在其他节点处理的时候，将K减1之后发现K不可能再出现第二次等于0的情况，那么就保证了result只能被赋值一次\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { int res, z; public int kthLargest(TreeNode root, int k) { z = k; traverseInOrder(root); return res; } private void traverseInOrder(TreeNode root) { if (root == null) return; //反着的中序遍历 traverseInOrder( root.right); z--; if (z == 0) res = root.val; traverseInOrder( root.left); } } 注意，z一定要是全局变量，否则每个节点的z的值都不一样，就失去了z的作用😂\n小小的优化：可以把递归终止条件改成if(root == null || z \u0026lt; 0) ，但是不改也能beats 100%了\n剑指 Offer 55 - II. 平衡二叉树 解法一（比较容易想到）：对根节点先序遍历子树得到深度，求差看看差是否小于等于1\n容易出错的点：在返回最终结果的时候会忽略对根节点的左右节点的是否是平衡二叉树的判断\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public boolean isBalanced(TreeNode root) { if (root == null) return true; /* * 要知道当前节点左右指数的深度之差是否大于一，那么就需要使用一个函数，它能够返回当前节点左右子树的深度 * */ int leftDepth = getDepth(root.left) ; int rightDepth = getDepth(root.right) ; //这里的返回值是最容易出错的，要记得判断左右子节点是否也是平衡二叉树。 return Math.abs(leftDepth - rightDepth) \u0026lt;= 1 \u0026amp;\u0026amp; isBalanced(root.left) \u0026amp;\u0026amp; isBalanced(root.right); } private int getDepth (TreeNode root) { if (root == null) return 0; int leftDepth = getDepth(root.left) ; int rightDepth = getDepth(root.right) ; return leftDepth \u0026gt; rightDepth ? leftDepth + 1 : rightDepth + 1; } } 由于每次都需要判断左右节点是否为二叉平衡树，因此时间复杂度就高了，$时间复杂度 = 每层执行复杂度 \\times 层数复杂度 = O(N×logN)。$\n最差情况下（为 “满二叉树” 时）， isBalanced(root) 遍历树所有节点，判断每个节点的深度 depth(root) 需要遍历 各子树的所有节点 。 满二叉树高度的复杂度 O(logN) ，将满二叉树按层分为 log(N+1) 层；\n解法二：保存子问题的结果，避免重复计算\n关于这个优化到 O(n) 算法,我们可以从以下几个方面说明:\n主要思路是在递归求解子问题时保存子问题的结果,避免重复计算。 在递归求树高函数 height() 中,我们不仅计算树高,还判断左右子树高度差是否 \u0026gt; 1。 如果左右子树高度差 \u0026gt; 1,直接返回 -1,表示这个子树不是平衡树,无需继续递归。 如果左右子树都平衡,则计算该节点的树高,并返回。 在函数 isBalanced() 中,如果 height() 返回 -1,则整棵树不平衡。如果返回 \u0026gt;= 0,则该树平衡。 这样就利用递归求解左右子树高度的同时,判断子树是否平衡,greatly减少了重复计算,降低时间复杂度。 每个节点只需要遍历一次,时间复杂度为 O(n)。 空间复杂度还是 O(n),为递归栈空间。 这种保存子问题结果,避免重复计算的思想,也是动态规划算法的核心。 所以这种优化主要利用的是递归遍历的特点,既能得到子树信息,又能做剪枝判断,从而提高效率。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public boolean isBalanced(TreeNode root) { //如果树根节点高度是-1,说明树非平衡,返回false return height(root) != -1; } public int height(TreeNode root) { //递归终止条件 if (root == null) { return 0; } //分别递归计算左右子树高度 int leftHeight = height(root.left); //如果左子树已经非平衡,直接返回-1 if(leftHeight == -1) { return -1; } int rightHeight = height(root.right); //如果右子树已经非平衡,直接返回-1 if(rightHeight == -1) { return -1; } //比较左右子树高度差 if (Math.abs(leftHeight - rightHeight) \u0026gt; 1) { //如果左右子树高度差\u0026gt;1,返回-1表示非平衡 return -1; } //如果该节点平衡,则计算该节点树高 return Math.max(leftHeight, rightHeight) + 1; } } 剑指 Offer 64. 求1+2+…+n 题目：\n求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。\n思路：利用 \u0026amp;\u0026amp; 的特性来实现递归的终止和继续\n1 2 3 4 5 6 7 8 9 10 class Solution { public int sumNums(int n) { return sum(n); } public int sum(int n) { boolean x = n \u0026gt; 0 \u0026amp;\u0026amp; (n = n + sum(n - 1)) \u0026gt; 0; return n; } } 这个程序首先检查n是否大于0。如果是，它会计算n与sum(n-1)的和，并将结果赋值给n。这个递归调用将继续直到n为0，此时递归结束。最终的结果就是1+2+\u0026hellip;+m。 注意，这个程序使用了逻辑与操作符(\u0026amp;\u0026amp;)，这是一种短路操作符。如果其左侧的表达式结果为false，那么它就不会执行右侧的表达式。在这种情况下，当n等于0时，递归调用就会结束\n20230716 剑指 Offer 68 - I. 二叉搜索树的最近公共祖先 二叉搜索树的特点：左子树\u0026lt;根节点\u0026lt;右子树\n祖先：一个节点也可以是它自己的祖先\n题目限制：p、q 为不同节点且均存在于给定的二叉搜索树中。\n由题目限制可知，两个节点必定存在于树中，因此对树不停的遍历，一定可以找到节点\n思路：对于根节点来说，p、q要么在左子树中、要么在右子树中、要么同时存在于左右子树中。p、q总有一个是大的，至于是哪个，暂且不管，我们假定p永远小于q，那么\n当root比q大的时候，p、q都在root的左子树中，我们继续对root的左子节点进行同样的判断 当root比p小的时候，p、q都在root的右子树中，我们继续对root的右子节点进行同样的判断 当上面两条不成立的时候，则说明root的左子节点不会是q的祖先，root的右子节点不会是p的祖先，此时，root就是p、q的最近公共祖先 代码思路：交换p、q的指针，保证p的值是小的 \u0026ndash;》 循环对root的值和p、q的值进行判断，满足思路第三点时退出循环，大于q时让root的左子节点成为新的root，小于p时让root的右子节点成为新的root。 \u0026ndash;》 循环终止条件是root为null \u0026ndash;》 函数返回root\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(p.val \u0026gt; q.val) { TreeNode tmp = p; p = q; q = tmp; } while (root != null) { if (root.val \u0026lt; p.val) { root = root.right; }else if (root.val \u0026gt; q.val) { root = root.left; }else { break; } } return root; } } 剑指 Offer 68 - II. 二叉树的最近公共祖先 题目限制条件：p、q 为不同节点且均存在于给定的二叉树中。\n思路：递归遍历根节点的右子树和左子树，如果在递归遍历的过程中能找到这个值相等的节点，则直接返回节点\n递归参数：待判断的节点root、p、q\n终止条件：这几个条件是或的关系\n1. root==null，成立则说明现在到树之外了，直接把null返回给上一层，这样上一层就能知道他的右子树或左子树没有找到合适的节点了 2. root.val == p.val，成立则说明找到p了，直接把p返回给上一层 3. root.val == q.val，成立则说明找到q了，直接把q返回给上一层 下一层参数：root.left,p,q 和 root.right,p,q\n结束递归之后的操作：\n如果左子树没找到节点而右子树找到了，可知两个节点都在右子树中，并且最先找到的那个就是当前获取到的返回值，则直接return 对右子树递归遍历得到的节点 右子树没找到左子树找到了同理 左右子树都没找到节点，则说明我这个节点下面的左右子树是不包含目标节点的，return null 告诉上一层我这个节点下面没有目标节点 递归函数返回值：root\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root == null || root == p || root == q) return root; TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if (left == null \u0026amp;\u0026amp; right == null) { return null; } if (left != null \u0026amp;\u0026amp; right == null) { return left; } if (left == null \u0026amp;\u0026amp; right != null) { return right; } return root; } } 2023/0717 剑指 Offer 37. 序列化二叉树 剑指 Offer 38. 字符串的排列 剑指 Offer 07. 重建二叉树 2023/0718 剑指 Offer 16. 数值的整数次方 2023/0719 剑指 Offer 33. 二叉搜索树的后序遍历序列 2023/0720 剑指 Offer 51. 数组中的逆序对 关键点：\n1.复盘归并排序的整个过程\n2.在拆分数组的时候要注意递归成立的条件是左指针小于右指针，不能等于，等于会造成mid=0时无限递归\n3.统计次数在大于的时候统计，需将左边部分在当前数右边的数字也统计进去\n4.在合并数组的时候，最后将数组复制回原数组的循环条件是left\u0026lt;=right , 因为只有left才能定位原数组的正确位置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Solution { int count = 0; public int reversePairs(int[] nums) { if(nums == null || nums.length==0) return 0; myMergeSort(nums, 0, nums.length-1, new int[nums.length]); return count; } private void myMergeSort(int[] arr, int left, int right, int[] tmp) { //这里不能写等于，因为mid向下取整，会导致left为0，right为1时mid为0，递归恒成立，栈溢出 if (left \u0026lt; right) { int mid = left + ((right - left) \u0026gt;\u0026gt; 1); myMergeSort(arr, left, mid, tmp); myMergeSort(arr, mid + 1, right, tmp); merge(arr, left, mid, right, tmp); } } private void merge(int[] arr, int left, int mid, int right, int[] tmp) { int le = left; int ri = mid + 1; int t = 0; while (le \u0026lt;= mid \u0026amp;\u0026amp; ri \u0026lt;= right) { //注意这里要写等于，保证else中统计的是逆序对。如果不写等于的话else中会把等于的情况也统计进去 if (arr[le] \u0026lt;= arr[ri]) { tmp[t++] = arr[le++]; }else { tmp[t++] = arr[ri++]; //这里要考虑左边的都是有序的，所以是当前次数加一得到count+1，然后左边部分的在当前数字右边的数都要加一次所以mid-le count = count + 1 + (mid - le); } } while (le \u0026lt;= mid) { tmp[t++] = arr[le++]; } while (ri \u0026lt;= right) { tmp[t++] = arr[ri++]; } t = 0; //注意这里是left\u0026lt;=right而不是t\u0026lt;=right，因为我们现在把数放回到原数组对应位置，只有left才能定位到原位置，t是不行的， //t只能用来定位tmp数组 while (left \u0026lt;= right) { arr[left++] = tmp[t++]; } } } 2023/0721 剑指 Offer 45. 把数组排成最小的数 传递性及交换位置后必为最小值的证明看此题解\n先给出快排代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class Solution { public String minNumber(int[] nums) { myQuickSort(nums, 0, nums.length-1); StringBuilder stringBuilder = new StringBuilder(); for (int i : nums) { stringBuilder.append(i); } return stringBuilder.toString(); } private void myQuickSort(int[] arr, int left, int right) { int mid = left + ((right - left) \u0026gt;\u0026gt; 1); //总是向下取整的中间值 int pivot = arr[mid]; int le = left; int ri = right; while (le \u0026lt; ri) { while (arr[le] \u0026lt; pivot) { le++; } while (arr[ri] \u0026gt; pivot) { ri--; } if (le \u0026gt;= ri) break; swap(arr, le, ri); if (greaterThan(arr[ri], pivot) == 0) { le++; } if (greaterThan(arr[le], pivot) == 0) { ri--; } } if (le == ri){ le++; ri--; } if (left \u0026lt; ri) { myQuickSort(arr, left, ri); } if (le \u0026lt; right) { myQuickSort(arr, le, right); } } private void swap(int[] arr, int le, int ri) { int tmp = arr[le]; arr[le] = arr[ri]; arr[ri] = tmp; } } 对快排修改后的代码：\n判断大小自定义了greaterThan方法，返回值为了避免等于号使用0、1、-1来保证指针能像原本快排那样正常移动 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 class Solution { public String minNumber(int[] nums) { myQuickSort(nums, 0, nums.length-1); StringBuilder stringBuilder = new StringBuilder(); for (int i : nums) { stringBuilder.append(i); } return stringBuilder.toString(); } private void myQuickSort(int[] arr, int left, int right) { int mid = left + ((right - left) \u0026gt;\u0026gt; 1); //总是向下取整的中间值 int pivot = arr[mid]; int le = left; int ri = right; while (le \u0026lt; ri) { while (greaterThan(arr[le], pivot) == -1) { le++; } while (greaterThan(arr[ri], pivot) == 1) { ri--; } if (le \u0026gt;= ri) break; swap(arr, le, ri); if (greaterThan(arr[ri], pivot) == 0) { le++; } if (greaterThan(arr[le], pivot) == 0) { ri--; } } if (le == ri){ le++; ri--; } if (left \u0026lt; ri) { myQuickSort(arr, left, ri); } if (le \u0026lt; right) { myQuickSort(arr, le, right); } } private void swap(int[] arr, int le, int ri) { int tmp = arr[le]; arr[le] = arr[ri]; arr[ri] = tmp; } private int greaterThan(int a, int b) { String bStr = String.valueOf(b); String aStr = String.valueOf(a); String aAddBStr = aStr + bStr; String bAddAStr = bStr + aStr; //拼接之后长度肯定一样，所以从最高位开始判断 for (int i = 0; i \u0026lt; aAddBStr.length(); i++) { if (aAddBStr.charAt(i) \u0026gt; bAddAStr.charAt(i)) { return 1; } if (aAddBStr.charAt(i) \u0026lt; bAddAStr.charAt(i)) { return -1; } } return 0; } } 2023/0722 剑指 Offer 61. 扑克牌中的顺子 关键点：如何确定数组中的数字是连续的？\n答：要保证两个条件：1. 数组中最大值与最小值（不包括0，因为0会代表任意数）之差小于5 2. 数组中的数除了0能重复，别的都不能重复\n同时满足上述两个条件则可确定数组中的数字是连续的\n方法一：使用额外的变量min和max和Set在遍历数组时赋值，如果出现除0之外有别的重复数字，那么false，遍历结束之后有了min和max，就可以判断是否是连续的\n方法二：对数组进行排序，排序结束之后对数组遍历，如果除0之外有别的数字和其下一个数字相等，那么返回false，最后用排序后的数组的最后一个元素和第一个元素之差判断是否连续\n方法一代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public boolean isStraight(int[] nums) { Set\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); //min初始超过牌堆数字的最大值，这样在遍历的时候才方便修改成最小值 int min = 15; int max = -1; for (int num : nums) { if (num == 0) continue; min = min \u0026lt; num ? min : num; max = max \u0026gt; num ? max : num; // 第一个判定条件：数组的值除了0之外不能重复 if (set.contains(num)) return false; set.add(num); } //第二个判定条件：最小值与最大值之差应该小于5 return max - min \u0026lt; 5; } } 方法二代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public boolean isStraight(int[] nums) { Arrays.sort(nums); //定义joker的数量，让最小值指向的位置正确 int joker = 0; for (int i = 0; i \u0026lt; 4; i++) { if (nums[i] == 0) { joker++; continue; } if (nums[i] == nums[i+1]) return false; } return nums[4] - nums[joker] \u0026lt; 5; } } 剑指 Offer 41. 数据流中的中位数 堆插入的时间复杂度：O(logN)\n从堆顶取元素的时间复杂度：O(1)\n思路：空间换时间，利用堆的特性，将所有数放到两个堆中，小根堆A存储数值较大的那一部分的数，大根堆存储数值较小的那一部分的数。且我们始终保证奇数个元素的时候，小根堆的元素多于大根堆，那么中位数就在小根堆中\n取值时如何取？\n答：\n当A、B中的元素个数相同的时候，取出两个堆的堆顶元素，求和然后除以2 当A、B中的元素个数不同的时候，中位数肯定是小根堆的堆顶元素 如何插入元素？\u0026mdash;- 分情况讨论\n情况一： 当堆A的元素个数和堆B的元素个数相同的时候，我们接下来使得小根堆的元素是较多的一方，那么能够直接把待插入的元素直接放到小根堆嘛？\n肯定是不行的，待插入元素应该比大根堆的最大元素还要大才能插入小根堆中，现在因为我们不确定他和大根堆中的元素的大小关系，无法确定他会比大根堆中最大的元素大，所以不能直接插入小根堆，应该先把待插入元素插入大根堆，得到大根堆的最大值，然后把大根堆的最大值弹出放到小根堆，这样，小根堆的堆顶元素就是中位数了\n情况二：当堆A的元素个数和堆B的元素个数不同的时候（小根堆会比大根堆多）,我们应该使得两个堆的数量相同，那么我们能够直接将大插入元素插入大根堆吗？\n当然也不行。待插入元素应该比小根堆的最小元素还要小才能直接将其插入大根堆，否则我们就应该从小根堆中挑选最小的数放入大根堆中，所以，应该先把待插入元素插入小根堆A，然后再从A中取栈顶元素放到大根堆B中。这样两个栈顶元素之和的一半就是中位数了\n需要用到的Java知识：\nPriorityQueue\n需要得到大根堆时PriorityQueue的构造函数参数为PriorityQueue\u0026lt;\u0026gt;(Comparator.reverseOrder());\nPriorityQueue底层比较时是c1.compareTo(c2)，在使用了\nPriorityQueue\u0026lt;\u0026gt;(Comparator.reverseOrder()); 之后，底层比较就会是c2.compareTo(c1);\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class MedianFinder { Queue\u0026lt;Integer\u0026gt; A,B; /** initialize your data structure here. */ public MedianFinder() { A = new PriorityQueue\u0026lt;\u0026gt;(); B = new PriorityQueue\u0026lt;\u0026gt;(Comparator.reverseOrder()); } public void addNum(int num) { //接下来应该让A的数量更大 if (A.size() == B.size()) { B.add(num); A.add(B.poll()); }else { A.add(num); B.add(A.poll()); } } public double findMedian() { return A.size() != B.size() ? A.peek() / 1.0 : (A.peek() + B.peek()) / 2.0; } } 2023/0724 剑指 Offer 42. 连续子数组的最大和 思路：若要达到O(N)的时间复杂度，那么就是要只遍历数组，对于连续子数组和的最小值，我们可以这么考虑：\n让数组的含义变成：到nums[i]前(包括nums[i])的连续子数组和的最大值，为了满足这个含义，我们需要遍历修改数组的值，修改方式如下：\n使用一个额外的变量res记录数组的第一个元素的值，然后从第二个元素开始遍历数组nums，对于当前遍历到的元素，我们判断当前元素加上前一个元素（此时前一个元素的含义已经变成前面的最大连续子数组和了）之后的值和当前元素的值相比谁更大，将更大的值赋给当前元素nums[i]，然后比较res和当前位置的值并更新res。\n遍历结束后返回res\n注意：res在此处是必要的，因为我们在修改数组的值的过程中，使用的是num[i-1]+nums[i], 数组的当前位置只能代表到他这里的最大和，但是如果他原本的值是负数，就会导致最大和变小，所以不能通过直接返回数组最后一位的方式来返回结果，只能用res去跟踪这个最大值。\n1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public int maxSubArray(int[] nums) { if(nums.length == 1) return nums[0]; int res = nums[0]; for(int i = 1; i \u0026lt; nums.length; i++) { nums[i] = Math.max(nums[i-1] + nums[i], nums[i]); res = res \u0026gt; nums[i] ? res : nums[i]; } return res; } } 剑指 Offer 15. 二进制中1的个数 跳了动态规划的题，直接到了位运算系列的题\n思路：对于任一个二进制数，如果最后一位为1则这个数和1相与得1，如果最后一位为0则这个数和1相与得0；那么我们对二进制数n从最后一位开始\u0026amp;1，每\u0026amp;一次我们就对n无符号右移一位（无符号右移会补0），直到n变成0即可停止。\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class Solution { // you need to treat n as an unsigned value public int hammingWeight(int n) { //利用res记录每次\u0026amp;的结果，只有\u0026amp;得1时才会增加res int res = 0; //这里没法用fori循环，因为还不知道n的长度，而且用n的长度不如对是否为0进行判断，因为判断为0了就不需要考虑前面的位了，fori还需要把每位都走一遍 while(n != 0){ res += n\u0026amp;1; n \u0026gt;\u0026gt;\u0026gt;= 1; } return res; } } 2023/0725 剑指 Offer 63. 股票的最大利润 2023/0727 剑指 Offer 65. 不用加减乘除做加法 拿几个数试一试才能理解代码的逻辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int add(int a, int b) { while(b != 0) { //得到进位，要想办法利用这个进位，怎么利用呢，那就是让b=c然后在下一次循环中求出a^b就能把进位算进去了。 //如果两个数相加之后没有进位，那么他们 \u0026amp; 之后的值位0，这样就能退出循环了 int c = (a \u0026amp; b) \u0026lt;\u0026lt; 1; //上一次循环得到的本位与当前的进位异或，这样就能得到各个位上的值 a = a ^ b; //让进位进入下一次循环来求出 a^b的结果 b = c; } return a; } } 剑指 Offer 56 - I. 数组中数字出现的次数 题目：一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。\n异或操作的特性：\n与自身异或的结果为0：a ^ a = 0 与0异或的结果是本身：a ^ 0 = a 异或操作满足交换律：a ^ b = b ^ a 异或操作满足结合律：a ^ (b ^ c) = (a ^ b) ^ c 先说说如果只有一个数字是不同的情况下该如何找到这一个数：\n根据异或的特点可以知道，两个相同的数异或得0，0和任意一个数异或会得到那个数本身，异或满足结合律，所以在一个数组中，由0开始异或，最后会得到那个唯一的数。\n本题的难点在于现在又两个唯一的数，只用0异或得到的最后的数没法还原出两个数，所以需要将数组里面的数分组，两个唯一的数各一组，然后相同的数在同一组，那么该如何分组呢？\n我们知道，对于数组里面所有的数从0开始异或之后，最后得到的数一定是两个唯一数异或的结果，那么对于两个不相等的数来说，他们的二进制位至少有一位是不同的，所以我们可以找出这个不同的位（该位经过异或运算肯定为1），又因为可能存在很多位不同，所以我们选择最低的一位，我们用1来开始逐位(使用 \u0026laquo;1 就可以逐位了)找到这一位，把这个变量记作mask，初始值为1，如果mask \u0026amp; 异或结果不为0，说明mask找到了不同点，否则让mask二进制中的1继续前进。\n现在我们有了mask，使用mask对数组里面的数分成两组，两个唯一数一定会被分成两个组，其他的数被分到哪组无所谓，因为同一对数字一定在同一组，分组的方式如下：对于唯一数A，A\u0026amp;mask为0时，唯一数B\u0026amp;mask一定为1，比如mask=0001 0000， A=1110 1111， B=0111 111，A和B在倒数第5位不同，所以会被分成两组。\n我们使用变量a，b，赋初始值为0，分组的同时进行异或运算，这样数组遍历结束之后就得到了结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public int[] singleNumbers(int[] nums) { //找到异或结果 int c = 0; for (int num : nums) { c ^= num; } //找到分组依据 int mask = 1; while ((mask \u0026amp; c) == 0) { mask \u0026lt;\u0026lt;= 1; } //利用a，b得到两组异或的结果 int a = 0, b = 0; for (int num : nums) { if ((num \u0026amp; mask) != 0) { a ^= num; }else { b ^= num; } } return new int[]{a, b}; } } 剑指 Offer 56 - II. 数组中数字出现的次数 II 题目：在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。\n判断某一位是否为1的方法：将那一位右移到最后一位，然后\u0026amp;1，其结果为1则知道那一位为1否则为0。\n|表示按位或，在按位或运算中，任何一个操作数的对应位是1，结果位就是1。按位或通常用来设置位，比如 x = x | (1 \u0026lt;\u0026lt; i) i要设置的位的下标\n思路：使用一个32长度的数组bitCount，遍历输入的数组记录每一个数在32位上出现的次数，将数组遍历完之后，bitCount每一位就是所有的数字的对应位数之和，题目说除了唯一数之外的其他数都出现了三次，那么我们将bitCount中的每一位替换成对3取余之后的值，这个值就是唯一数在各个位上能出现的值。\n同时，为了在替换过程中得到结果，我们使用|按位或运算来设置res的每一位，这样一次遍历bitCount就能得到最后的结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution{ public int getRes(int[] nums) { //新建32长度的数组bitCount int[] bitCount = new int[32]; for(int num : nums) { for(int i = 0; i \u0026lt; bitCount.length; i++) { //利用i得到对应位的值，这里实际上是逆序的，不是实际的数据，这是因为利用i更容易求得位数，读者也可以自行修改此处逻辑，我在这里逆序之后，下面还原的时候会把顺序也还原 bitCount[i] += (num \u0026gt;\u0026gt; i) \u0026amp; 1; } } int res = 0; for(int i = 0; i \u0026lt; bitCount.length; i++) { //在将每一个元素取余3的同时求出结果, 要用 | 来设置位，同时因为i刚好和上面的顺序相反，所以顺序也能还原 res |= (bitCount[i] % 3) \u0026lt;\u0026lt; i; } } } 时间复杂度O(N)\n空间复杂度O(1), 因为bitCount长度固定\n2023/0728 剑指 Offer 39. 数组中出现次数超过一半的数字 本题有三种方法：hashMap求解、排序取中位数求解、摩尔投票法求解\n方法名 时间复杂度 空间复杂度 hashMap求解 O(N) O(N) 排序取中位数 O(NlogN) O(1) 摩尔投票法 O(N) O(1) 综合来看，摩尔投票法的时空复杂度最优\n摩尔投票法思路：对于一个数字，我们记录他的初始票数为1，让这个数字和其他数字接触，如果两数不相等，那么票数就减少1，相等则加一，当票数为0的时候，我们开始记录下一个数，循环上面的过程，直到数组遍历完。由于题目要求的数的票数超过数组长度的一半，所以这个数的票数肯定能保持到最后，其他数字的票数都会被消耗掉\n一个形象的比喻：\n玩一个诸侯争霸的游戏，假设你方人口超过总人口一半以上，并且能保证每个人口出去干仗都能一对一同归于尽。最后还有人活下来的国家就是胜利。那就大混战呗，最差所有人都联合起来对付你（对应你每次选择作为计数器的数都是众数），或者其他国家也会相互攻击（会选择其他数作为计数器的数），但是只要你们不要内斗，最后肯定你赢。最后能剩下的必定是自己人。\n作者：知乎用户 链接：https://www.zhihu.com/question/49973163/answer/617122734\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int majorityElement(int[] nums) { //该变量记录当前得票最多的数字 int mostVotesNum = 0; //该变量记录当前数字的票数 int votes = 0; for (int num : nums) { //如果票数为0，说明当前得票最多的数字应该换了 if (votes == 0) { mostVotesNum = num; } //对votes的值进行修改 votes += mostVotesNum == num ? 1 : -1; } return mostVotesNum; } } hashmap求解思路：利用map和两个变量res、times，res记录结果，times根据当前遍历到的数字进行更新，若当前遍历到的数字出现次数大于times，那么更新times和res，最后返回res；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int majorityElement(int[] nums) { //该变量记录当前得票最多的数字 int mostVotesNum = 0; //该变量记录当前数字的票数 int votes = 0; HashMap\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int num : nums) { if (map.containsKey(num)) { map.put(num, map.get(num)+1); }else { map.put(num, 1); } if (votes \u0026lt; map.get(num)) { mostVotesNum = num; votes = map.get(num); } } return mostVotesNum; } } 剑指 Offer 66. 构建乘积数组 对于a[i]来说要求其除了他之外的所有和，最容易想到的就是将所有和的元素相乘，然后遍历的时候直接除去a[i]本身，但是由于题目限制不允许使用除法，所以这个方法不行\n思路：对于a[i]来说要求其除了他之外的所有和，实际上就是求其左边所有数字的乘积 * 右边所有数字的乘积，所以我们可以创建两个辅助数组left和right，第一次遍历(顺序遍历)使得left[i]为a[i]左边所有的数字乘积，由于a[0]左边没有数字，所以left[0]=1.\n第二次遍历(逆序遍历)使得right[i]为a[i]右边所有的数字乘积，由于a[a.length-1]右边没有数字，所以righ[a.length-1]=1.\n第三次遍历我们可以直接修改a中各个位置的值，让a[i]=left[i]*right[i]，这样我们就能得到答案了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int[] constructArr(int[] a) { if (a == null || a.length == 0) return a; //left[i]表示a[i]的左边所有元素的乘积 int[] left = new int[a.length]; left[0] = 1; //right[i]表示a[i]的右边所有元素的乘积 int[] right = new int[a.length]; right[right.length - 1] = 1; for (int i = 1; i \u0026lt; a.length; i++) { left[i] = a[i-1] * left[i-1]; } for (int length = a.length - 2; length \u0026gt;= 0; length--) { right[length] = a[length+1] * right[length+1]; } //这里其实直接改a数组不用res数组也行，最后返回a即可 int[] res = new int[a.length]; for (int i = 0; i \u0026lt; a.length; i++) { res[i] = left[i]*right[i]; } return res; } } 剑指 Offer 14- I. 剪绳子 数学知识：\n均值不等式 $\\sqrt{ab}≤(a+b)/2$\n均值不等式推广式 ：(n个正数相加）/n ≥ n次根号下（n个正数相乘）\n$\\frac{n_1+n_2+n_3+\u0026hellip;+n_a}{a} \\geq \\sqrt{n_1n_2n_3*\u0026hellip;*n_a}$\n要求多个n相乘的最大值，那么就是找出一个长度x，使得a个x相乘的结果最大，又因为总长度为n, 则有函数 $y=x^a ==\u0026gt; y=x^\\frac{n}{x}$ , 当n一定时，我们对 $y=x^\\frac{1}{x}$求最值，发现最值点不是整数，接下来根据单调性找到离最值点最近的两个整数2和3，发现函数在带入3时是最大的，所以 函数$y=x^\\frac{1}{x}$的最大值就是$f(3)$ , 也就是说，当长度x为3时，将长度n分成a段得到的函数最最大\n函数单调性如下\n由图可知，当x=3时取值最大。\n思路：根据不等式、函数最值点、单调性可知，当x=3时，对n取a段长度为三的线段能让线段之积最大，但是如果n不是3的整数倍，就会出现余数1、2\n对于余数为1的时候，我们需要知道f(n-1)*1和f(n-3)*4谁更大，这里的f(n-3)*4表示将一个3拿出来和1组合成2*2，经过计算后者一定大于前者，所以当余数为1的时候，我们要返回 3^(a-1)*4作为最终结果\n对于余数为2的时候，说明最后一段的长度为1，由于Java中除法是向下取整的，所以还需要把最后一段乘进去\n1 2 3 4 5 6 7 8 9 10 11 class Solution { public int cuttingRope(int n) { if (n \u0026lt;= 3) return n-1; int a = n/3; int b = n % 3; if (b == 0) return (int) Math.pow(3, a); //特殊点：当余数（即剩余的线段长度）为1时，需要将一个3拿出来，和1组合到一起成为2*2=4，来求得最大值 if (b == 1) return (int) (Math.pow(3, a-1)*4); return (int) (Math.pow(3, a) * b); } } 2023/0729 剑指 Offer 14- II. 剪绳子 II 思路和上一题是一样的，但是多了边界条件，所以需要考虑int32溢出的情况\n第一版出错代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public int cuttingRope(int n) { if (n \u0026lt;= 3) return n-1; int a = n / 3; int b = n % 3; if (b == 0) return pow(3, a); if (b == 1) return pow(3, a-1) * 4 % 1000000007; return pow(3, a) * b % 1000000007; } //快速幂 private int pow(int baseNum, int power) { int res = 1; while (power \u0026gt; 0) { //奇数 if ((power \u0026amp; 1) == 1) { res = baseNum * res % 1000000007; power -= 1; } baseNum = baseNum * baseNum % 1000000007; power \u0026gt;\u0026gt;= 1; } return res; } } 出错原因在于没有考虑到在快速幂中对于底数和结果计算的int类型越界问题。res = baseNum * res % 1000000007;有可能在右边计算乘法的时候已经越界了，那么越界之后对于1e7取模肯定也是错的。baseNum = baseNum * baseNum % 1000000007;这一行也是同理\n改进代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public int cuttingRope(int n) { if (n \u0026lt;= 3) return n-1; int a = n / 3; int b = n % 3; if (b == 0) return (int) pow(3, a); if (b == 1) return (int) (pow(3, a-1) * 4 % 1000000007); return (int) (pow(3, a) * b % 1000000007); } //快速幂 private long pow(int baseNum, int power) { long res = 1; while (power \u0026gt; 0) { //奇数 if ((power \u0026amp; 1) == 1) { res = baseNum * res % 1000000007; power -= 1; } //在这里转为long进行计算后再变成int，保证结果是正确的 baseNum = (int) ((long)baseNum * baseNum % 1000000007); power \u0026gt;\u0026gt;= 1; } return res; } } 进一步修改，提高代码可读性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public int cuttingRope(int n) { if (n \u0026lt;= 3) return n-1; int a = n / 3; int b = n % 3; long res = 1; //使用switch来代替if，感觉更好些 switch (b) { case 0: { res = pow(3, a); break; } case 1: { res = pow(3, a-1) * 4 % 1000000007; break; } case 2: { res = pow(3, a) * b % 1000000007; } } return (int) res; } //baseNum直接一开始就使用long类型接收参数 private long pow(long baseNum, int power) { long res = 1; while (power \u0026gt; 0) { //奇数 if ((power \u0026amp; 1) == 1) { res = baseNum * res % 1000000007; power -= 1; } baseNum = baseNum * baseNum % 1000000007; power \u0026gt;\u0026gt;= 1; } return res; } } 剑指 Offer 57 - II. 和为s的连续正数序列 这题本来应该使用数学方法来求解，但是我选择了滑动窗口，如果之后有时间会将数学方法补上\n滑动窗口解法：其实就是窗口内的总和大于target则左边界右移同时让总和减去旧的左边界，小于target则让右边界右移同时让总和加上新的右边界，等于则根据左边界值和右边界值生成一个数组存到list，然后让右边界右移同时总和加上新的右边界\n易错点：1. 边界移动时忘记更新总和\t2.相等时在得到答案序列后忘记让右边界右移和更新总和\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public int[][] findContinuousSequence(int target) { List\u0026lt;int[]\u0026gt; resList = new ArrayList\u0026lt;\u0026gt;(); int front = 1; int rear = 2; int sum = 3; //初始时rear的值就比front大1，且front的值小于rear才会进入，这两个条件按证了至少有两个数字组成一个序列 while (front \u0026lt; rear) { if (sum \u0026lt; target) { rear++; sum = sum + rear; }else if (sum \u0026gt; target) { sum -= front; front++; }else { resList.add(getSubRes(front, rear)); rear++; sum += rear; } } return resList.toArray(new int[0][]); } private int[] getSubRes(int front, int rear) { int[] arr = new int[rear - front + 1]; for (int i = 0; i \u0026lt; arr.length; i++) { arr[i] = front++; } return arr; } } 剑指 Offer 62. 圆圈中最后剩下的数字 一句话概括：数组延长后取模求实际位置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int lastRemaining(int n, int m) { //因为我们知道最后删除的数字下标和数字的值是一样的，因为数组的元素从0开始，数组的下标也是从0开始 //由于最后留下的元素的数组下标一定是0.所以我们可以反推删除前的这个元素的下标，怎么推呢？ //我们可以很容易想到，最后一次剩下的数组长度为1，那么上一次的数组长度就是2 //我们可以假设上一轮的数量为当前剩余轮剩余个数+m，也就是让上一轮的数组长度的是(当前留下来的下标+待移动的步数) //然后，由于实际数组的长度并没有这么长，所以我们要求出当前下标+待移动步数之后放到循环数组里面的真实下标，也就是对实际数组长度取模，循环上面的过程直到数组的长度到了最开始的长度n //最后一次的下标是0 int ans = 0; //从2开始，表义清晰一些，表示接下来要还原倒数第二轮的实际下标 for(int i = 2; i \u0026lt;= n; i++){ ans = (ans + m) % i; } return ans; } } 2023/0730 剑指 Offer 43. 1～n 整数中 1 出现的次数 推荐题解：https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/python3si-lu-dai-ma-10fen-zhong-jiang-qi-9btr/，视频+代码讲的都很好\n剑指 Offer 44. 数字序列中某一位的数字 这题是通过找规律来进行求解的。\n思路：\n将数字分区间，按一位数字、两位数字、三位数字分区间，一位数字的起始元素是1，这是为了保证规律能通用。\n对于这些区间，我们加上几个关键概念给他们\n数位位数：count，这个区间的数字需要使用多少位来表示，比如[1-9]区间每一个数字只占用一位，且有九个数字，那么这个区间的count就是9；区间[10-99]区间每个数字占用两位，且有90个数字，那么这个区间的数位位数就是180 区间首元素：start，表示这个区间开始的第一个数字 位数：digits，表示这个区间的数字是1位数还是2位数还是3位数 确定了上面几个概念之后，我们接下来进行三步操作\n确定n所指向的数位在哪个区间中，这就需要n和count之间的大小关系来判断 确定具体的数num，这就需要使用start和n与dights之间的关系 确定数num中的第几位是我们需要的数字，这也需要使用start和n与dights之间的关系 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public int findNthDigit(int n) { if (n \u0026lt;= 9) return n; //区间范围：[1-9] [10-99] [100-999] //数字数量：9 90 900 //数位数量：9 180 2700 //位数： 1 2 3 //起始数字：1 10 100 //对初始区间第一位start进行初始化 long start = 1; //对位数进行初始化，第一段区间的数字只有1位 int digits = 1; //对区间内的数位数量进行初始化，第一段区间只有9个数字，这九个数字都是1位数，所以占用的数位数量是9 long count = 9; //判断n剩余的位数是否还能大于指定区间的数位数量 while (n \u0026gt; count) { //n要逐渐减去区间的数位数量，当n\u0026lt;=count说明n所在的区间找到了, 可以方便的表示出此时n在区间中的相对位置（此处相对位置可以理解成下标） n -= count; //让start、digits、count都变成下一个区间的对应值，start、digits是横向规律，count是纵向规律（也就是在同一区间找出等式） start *= 10; digits++; count = 9 * digits * start; } //找到区间内的具体数字，也是找规律，可以用区间[10-99]尝试 start+n、start+n-1、start+(n-1)/2 发现只有最后一个能找到正确的数字 //这里使用额外的变量num来记录找到的数字，当然也可以修改start来记录因为后面也不需要区间初始值这个含义了 long num = start + (n-1) / digits; //找到这个数字中那一位是我们需要的 int homologousDigit = (n-1) % 10; //获取对应的数字 return Long.toString(num).charAt((n - 1) % digits) - \u0026#39;0\u0026#39;; // 3. } } 参考文档 Markdown语言——数学公式\n","permalink":"https://paper.3kis.top/posts/tech/leetcode-keytooffer/","summary":"刷题顺序按照：https://leetcode.cn/studyplan/coding-interviews/ 本题解中标题是链接，会直接跳转","title":"leetcode剑指Offer题解记录"},{"content":"hugo上手使用 安装\n在win10下推荐使用 scoop install hugo-extended 来安装hugo的拓展版，基础版本与拓展版本的命令一样，但是extended版本有更好的效果。\n使用hugo命令新建一个能让hugo识别的目录\n1 hugo new site blog 其中blog是自定义的目录名\n进入目录\n1 cd blog 在blog目录下git clone主题\n这里需要将stack主题fork到自己的github，以便于后续的修改能够push 注意！！ 如果想要后面能够使用github action，那么必须必须必须使用submodule的方式引入！！而不能是git clone的方式\ngit clone xxxx.git themes/stack\n1 git submodule add xxxx.git themes/stack stack这个目录名是自定义的\n修改根目录config.toml\n在文件中添加\n1 theme = \u0026#39;stack\u0026#39; 在根目录下执行命令来构建\n1 hugo 运行查看网站效果\n1 hugo server 完整命令行步骤\n1 2 3 4 5 6 hugo new site blog cd blog git submodule add your_stack_repo.git themes/stack echo theme=\u0026#39;stack\u0026#39; \u0026gt;\u0026gt; config.toml hugo hugo server 完整的文件目录\nDIY环节 上面的步骤只能让我们看到网站简单的效果并上传文件，还需要做进一步的美化。\n静态文件处理 将themes/stack/exampleSite/content/的page目录复制到blog目录的content目录下 这样你就有了下面这几个在左侧边栏 修改stack目录下的config.yml 根据exampleSite目录下的config.yaml的内容，选取自己需要的内容复制粘贴到stack目录下的config.yaml并diy 下面是我的修改后的文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 module: hugoVersion: extended: true min: \u0026#34;0.87.0\u0026#34; # 上面的保持不变，表明这是一个submodule # 下面的参考exampleSite的yml配置，从exampleSite的config.yml的params开始参考 params: mainSections: - post featuredImageField: image rssFullContent: true favicon: footer: since: customText: dateFormat: published: Jan 02, 2006 lastUpdated: Jan 02, 2006 15:04 MST sidebar: compact: false emoji: ✅ subtitle: hello~ avatar: enabled: true local: true # 静态资源存放在stack目录下的asset目录,因为当前配置文件是在stack目录下，所以静态资源目录的路径就是当前目录的asset目录 src: /img/OIP.png article: math: false toc: true readingTime: true license: enabled: false default: Licensed under CC BY-NC-SA 4.0 comments: enabled: false provider: disqus disqusjs: shortname: apiUrl: apiKey: admin: adminLabel: utterances: repo: issueTerm: pathname label: remark42: host: site: locale: vssue: platform: owner: repo: clientId: clientSecret: autoCreateIssue: false # Waline client configuration see: https://waline.js.org/en/reference/client.html waline: serverURL: lang: visitor: avatar: emoji: - https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo requiredMeta: - name - email - url placeholder: locale: admin: Admin twikoo: envId: region: path: lang: giscus: repo: repoID: category: categoryID: mapping: strict: lightTheme: darkTheme: reactionsEnabled: 1 emitMetadata: 0 inputPosition: lang: gitalk: owner: admin: repo: clientID: clientSecret: cusdis: host: id: widgets: # homepage: [] # page: [] homepage: - type: search - type: archives params: limit: 5 - type: categories params: limit: 10 - type: tag-cloud params: limit: 10 page: - type: toc opengraph: twitter: # Your Twitter username site: # Available values: summary, summary_large_image card: summary_large_image defaultImage: opengraph: enabled: false local: false src: colorScheme: # Display toggle toggle: true # Available values: auto, light, dark default: auto imageProcessing: cover: enabled: true content: enabled: true # 注意yml的语法是下一行缩进2个空格 menu: main: - indetifier: categories name: categories url: /categories/ weight: 30 - indetifier: tag name: tags url: /tags/ weight: 30 这里说一下为什么我选择修改stack目录下的config.yaml文件而不是根目录下的config.toml文件\n1.因为我认为主题的配置应该在主题目录中而不是在根目录对于整个站点的配置中，如果以后需要使用其他主题，那么就不用过多的修改config.toml文件\n2.当我们在命令行中运行hugo命令的时候，可以发现，hugo是会将根目录下的config.toml和主题目录下的config.yaml文件同时当成配置文件来处理的，所以我们在stack目录下的配置文件也是可以生效的\n需要注意的是，如果需要配置markup参数，需要在根目录下的配置文件进行配置，猜测是因为这个配置项不属于主题，而属于hugo本身，所以在主题目录下的配置文件中无效\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 ├─archetypes ├─assets ├─content │ ├─page │ │ ├─about │ │ ├─archives │ │ ├─links │ │ └─search │ └─post ├─public │ ├─categories │ ├─img │ ├─page │ ├─post │ ├─scss │ ├─tags ├─resources └─themes └─stack ├─archetypes ├─assets │ ├─icons │ ├─img │ ├─scss │ └─ts ├─data ├─exampleSite │ └─content │ ├─categories │ │ └─Test │ ├─page │ │ ├─about │ │ ├─archives │ │ ├─links │ │ └─search │ └─post │ ├─chinese-test │ ├─emoji-support │ ├─markdown-syntax │ ├─math-typesetting │ ├─placeholder-text │ └─rich-content ├─i18n ├─images └─layouts 得到第一篇文章 现在，我们可以复制blog\\themes\\stack\\exampleSite\\content\\post目录下的一篇文章到根目录下的content\\post.这里我选择markdown-syntax目录。\n粘贴完之后，在命令行中运行\n1 2 hugo hugo server 然后就可以在localhost:1313看到自己的文章了\n配置Github Pages与GitHub Actions 现在，在本地我们已经可以看到页面了，但是还希望能通过网络让别人访问到我们的博客，所以需要借助GitHub Pages和Github Actions\nGithub Pages 首先在 GitHub 上创建一个 public repository，命名为 username.github.io（根据 GitHub Pages，如果想用这个域名作为博客地址，repo 必须命名为 username.github.io)。这个 repo 会用来存放博客的静态文件，也就是 hugo 创建的public文件夹。(username是自己的GitHub用户名)\n执行下面的命令\n1 2 3 4 5 6 cd public git init git add remote origin username/username.github.io git add . git commit -m \u0026#34;init commit\u0026#34; git push --set-upstream origin main 现在打开https://username.github.io， 应该就可以看到和localhost:1313一样的内容了\nGithub Actions 接下来创建一个另外的 private repository（e.g. blog_source），用这个来存放原始文件（也就是整个根目录），以及设置用于自动部署的 GitHub Actions。GitHub Actions 设置还参考了 Hugo 官方教程。\n在根目录下，新建目录.github\\workflows\\, 在这个目录中创建gh-pages.yml文件，内容为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 name: hugo CI on: push: branches: [ main ] jobs: build: runs-on: ubuntu-20.04 steps: # 如果stack使用了远程仓库，那么必须以submodule的方式引入才能正常跑通现在这个github action。 # 当stack主题是通过submodule的方式来拉取的时候，应该采用下面四行代码来进行action的构建. - uses: actions/checkout@v2 with: submodules: true fetch-depth: 1 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: #不使用hugo的最新版是因为最新版和stack主题有兼容性问题，此问题并未得到stack作者的解决 hugo-version: 0.111.3 extended: true - name: Build run: hugo - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: personal_token: xxxxxxx #写自己的GitHub personal token external_repository: username/username.github.io # the public repo hosting website publish_branch: main # branch hosting the website publish_dir: ./public commit_message: ${{ github.event.head_commit.message }} 上面的示例中，后面有注释的行都需要自己去确认是否正确填入\n因为我们需要从博客仓库推送到外部 GitHub Pages 仓库，需要特定权限，要在 GitHub 账户下 Setting - Developer setting - Personal access tokens 下创建一个 Token。\n创建自己的 Github Personal Key\n权限需要勾选 repo 与 workflow。\n配置后复制生成的 Token（注：只会出现一次），然后在我们博客源仓库的 Settings - Secrets - Actions 中添加 PERSONAL_TOKEN 环境变量为刚才的 Token，这样 GitHub Action 就可以获取到 Token 了。\n完成上述配置后，推送代码至仓库，即可触发 GitHub Action，自动生成博客页面并推送至 GitHub Pages 仓库。\n现在在我们本地的hugo站点根目录blog关联到远程的blog_source仓库\n1 2 3 4 5 6 echo \u0026#34;public/\u0026#34; \u0026gt;\u0026gt; .gitignore git init git remote add origin https://github.com/username/blog_source.git git add . git commit -m \u0026#34;init\u0026#34; git push --set-upstream origin main 注意：将 public\\目录放到ignore文件中是必须要做的，因为public目录和另外的远程仓库关联了，对于git来说，如果想要拉取一个目录而同时在这个目录中有一个子目录被其他远程仓库关联了，那么要么把public作为一个submodule要么把public忽略。\n由于我们在Github Actions里对public进行推送，所以前者submodule的方式就不用考虑，选择后者。\n之后我们只需要执行\n1 2 3 git add . git commit -m \u0026#34;create a post\u0026#34; git push 就能自动部署到两个远程仓库了\n在 stack 主题中开启 latex 支持 找到这个head.html文件\n1 themes/stack/layouts/partials/head/head.html 在文件末尾加上\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;!-- MathJax configuration for LaTeX support --\u0026gt; \u0026lt;script\u0026gt; window.MathJax = { tex: { inlineMath: [[\u0026#39;$\u0026#39;, \u0026#39;$\u0026#39;], [\u0026#39;\\\\(\u0026#39;, \u0026#39;\\\\)\u0026#39;]], // 行内公式定界符 displayMath: [[\u0026#39;$$\u0026#39;, \u0026#39;$$\u0026#39;], [\u0026#39;\\\\[\u0026#39;, \u0026#39;\\\\]\u0026#39;]], // 块级公式定界符 processEscapes: true, tags: \u0026#39;ams\u0026#39; // 启用 AMS 数学环境 }, svg: { fontCache: \u0026#39;global\u0026#39; } }; \u0026lt;/script\u0026gt; \u0026lt;script id=\u0026#34;MathJax-script\u0026#34; async src=\u0026#34;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-svg.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 完整的文件内容如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \u0026lt;meta charset=\u0026#39;utf-8\u0026#39;\u0026gt; \u0026lt;meta name=\u0026#39;viewport\u0026#39; content=\u0026#39;width=device-width, initial-scale=1\u0026#39;\u0026gt; {{- $description := partialCached \u0026#34;data/description\u0026#34; . .RelPermalink -}} \u0026lt;meta name=\u0026#39;description\u0026#39; content=\u0026#39;{{ $description }}\u0026#39;\u0026gt; {{ with .Params.Keywords }}\u0026lt;meta name=\u0026#34;keywords\u0026#34; content=\u0026#34;{{ delimit . \u0026#34;, \u0026#34; }}\u0026#34;\u0026gt;{{ end }} {{- $title := partialCached \u0026#34;data/title\u0026#34; . .RelPermalink -}} \u0026lt;title\u0026gt;{{ $title }}\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#39;canonical\u0026#39; href=\u0026#39;{{ .Permalink }}\u0026#39;\u0026gt; {{- partial \u0026#34;head/style.html\u0026#34; . -}} {{- partial \u0026#34;head/script.html\u0026#34; . -}} {{- partial \u0026#34;head/opengraph/include.html\u0026#34; . -}} {{- range .AlternativeOutputFormats -}} \u0026lt;link rel=\u0026#34;{{ .Rel }}\u0026#34; type=\u0026#34;{{ .MediaType.Type }}\u0026#34; href=\u0026#34;{{ .Permalink | safeURL }}\u0026#34;\u0026gt; {{- end -}} {{ with .Site.Params.favicon }} \u0026lt;link rel=\u0026#34;shortcut icon\u0026#34; href=\u0026#34;{{ . }}\u0026#34; /\u0026gt; {{ end }} {{- template \u0026#34;_internal/google_analytics.html\u0026#34; . -}} {{- partial \u0026#34;head/custom.html\u0026#34; . -}} \u0026lt;!-- MathJax configuration for LaTeX support --\u0026gt; \u0026lt;script\u0026gt; window.MathJax = { tex: { inlineMath: [[\u0026#39;$\u0026#39;, \u0026#39;$\u0026#39;], [\u0026#39;\\\\(\u0026#39;, \u0026#39;\\\\)\u0026#39;]], // 行内公式定界符 displayMath: [[\u0026#39;$$\u0026#39;, \u0026#39;$$\u0026#39;], [\u0026#39;\\\\[\u0026#39;, \u0026#39;\\\\]\u0026#39;]], // 块级公式定界符 processEscapes: true, tags: \u0026#39;ams\u0026#39; // 启用 AMS 数学环境 }, svg: { fontCache: \u0026#39;global\u0026#39; } }; \u0026lt;/script\u0026gt; \u0026lt;script id=\u0026#34;MathJax-script\u0026#34; async src=\u0026#34;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-svg.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 修改之后, 在 submodule 中add commit push 然后再回到父repo 中进行add commit push\n根据Hugo官方的方式创建文章 在blog目录下执行命令\n1 hugo new posts/my-first-post/index.md Hugo created the file in the content/posts/my-first-post directory. Open the file with your editor.\n打开文件会发现文章顶部是\n1 2 3 4 5 --- title: \u0026#34;My First Post\u0026#34; date: 2022-11-20T09:03:20-08:00 draft: true --- draft: true表明当前文章是草稿，执行``hugo 和 hugo server`之后不会生成对应的文章在网页上膳食\n根据Stack官网的方式调整文章 文章顶部可以有下面这几个字段\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 +++ author = \u0026#34;Asher\u0026#34; title = \u0026#34;Markdown Syntax Guide\u0026#34; date = \u0026#34;2023-06-24\u0026#34; description = \u0026#34;Sample article showcasing basic Markdown syntax and formatting for HTML elements.\u0026#34; tags = [ \u0026#34;markdown\u0026#34;, \u0026#34;css\u0026#34;, \u0026#34;html\u0026#34;, \u0026#34;themes\u0026#34;, ] categories = [ \u0026#34;themes\u0026#34;, \u0026#34;syntax\u0026#34;, ] series = [\u0026#34;Themes Guide\u0026#34;] image = \u0026#34;cover.jpg\u0026#34; +++ tag表示文章的标签，我们不需要手动创建标签，只需要在文章顶部写上我们想设置的标签，stack主题和hugo会帮助我们生成tag。categories字段同理\nimage字段表示封面图，路径一般和文章一样\n文章顶部可以是toml格式也可以是yml格式，但是不能混用\n在新的电脑上继续你的 hugo 首先 git clone 源仓库是必不可少的, 但是一定要记得把 submodule 给初始化好, 这样在 git action 的构建中才能以最新的 submodule 来构建 hugo 站点\n1 git submodule update --init 如果在 github 远程仓库上面改动了 submodule 的仓库, 记得在本地仓库下执行\n1 git submodule update --remote themes/stack 当然还是更推荐 init之后在本地改动, 而不是在远程仓库改动, 因为我没有做过直接在远程仓库改动的实验\n参考资料 Hugo + GitHub Action，搭建你的博客自动发布系统 不是从零开始的 Hugo 建站笔记 GitHub Docs Hugo 官网 Stack Docs ","permalink":"https://paper.3kis.top/posts/tech/hugo-best-practice/","summary":"hugo上手使用 安装 在win10下推荐使用 scoop install hugo-extended 来安装hugo的拓展版，基础版本与拓展版本的命令一样，但是extended版本有更好的效果。","title":"Hugo 最佳实践"},{"content":"在D盘下执行 irm get.scoop.sh -outfile 'install.ps1'\n如果提示无法解析 raw.githubusercontent.com 那么就在host文件中添加 185.199.108.133 raw.githubusercontent.com 然后保存为ASCI编码\n在D盘创建D:\\Scoop\\UserScoopApps 和 D:\\Scoop\\GlobalScoopApps这两个目录 接下来执行\n1 .\\install.ps1 -ScoopDir \u0026#39;D:\\Scoop\\UserScoopApps\u0026#39; -ScoopGlobalDir \u0026#39;D:\\Scoop\\GlobalScoopApps\u0026#39; -NoProxy 这里最好global和非global的目录不是同一个，因为同一个的话会导致每次下一个app都会多下一个全局的\n如果上面的命令报错提示没有管理员权限, 可以尝试把命令换成\n.\\install.ps1 -RunAsAdmin -ScoopDir \u0026lsquo;D:\\Scoop\\UserScoopApps\u0026rsquo; -ScoopGlobalDir \u0026lsquo;D:\\Scoop\\GlobalScoopApps\u0026rsquo; -NoProxy\n安装完之后要重启电脑或者任务管理器中重启资源管理器之后才能在powershell和cmd中都生效，不重启不只能在powershell中使用\n常用bucket Name Source\nAsh258 https://github.com/Ash258/Scoop-Ash258.git cvp https://github.com/SayCV/scoop-cvp.git dorado https://github.com/chawyehsu/dorado echo https://github.com/echoiron/echo-scoop extras https://github.com/ScoopInstaller/Extras java https://github.com/ScoopInstaller/Java Main https://github.com/ScoopInstaller/Main.git nerd-fonts https://github.com/matthewjberger/scoop-nerd-fonts nirsoft https://github.com/kodybrown/scoop-nirsoft nonportable https://github.com/ScoopInstaller/Nonportable Scoop-Apps https://github.com/ACooper81/scoop-apps scoop-bear https://github.com/AStupidBear/scoop-bear scoopcn https://github.com/scoopcn/scoopcn.git versions https://github.com/ScoopInstaller/Versions\n添加bucket：\n1 2 3 scoop bucket add extras https://github.com/ScoopInstaller/Extras scoop bucket add Scoop-Apps https://github.com/ACooper81/scoop-apps scoop bucket add versions https://github.com/ScoopInstaller/Versions 常用命令 使用scoop的shim来添加环境变量path scoop shim add $习惯命令名 $执行命令的文件(格式为：路径+文件名。如果不确定是哪一个文件起作用就去chatgpt问一问) 切换软件版本 scoop reset \u0026lt;java\u0026gt;[@\u0026lt;version\u0026gt;]\n删除旧版本 scoop cleanup \u0026lt;app\u0026gt;\npowershell命令 以其他命令的结果作为另一命令的一部分 在 PowerShell 中，可以使用 $() 语法将命令的返回值作为参数传递给其他命令。\n","permalink":"https://paper.3kis.top/posts/tech/install-scoop-in-win10/","summary":"在D盘下执行 irm get.scoop.sh -outfile 'install.ps1' 如果提示无法解析 raw.githubusercontent.com 那么就在host文件中添加 185.199.108.133 raw.githubusercontent.com 然后保存为ASCI编码 在D盘创建D:\\Scoop\\UserScoopAp","title":"Scoop自定义安装与使用"},{"content":"","permalink":"https://paper.3kis.top/links/","summary":"","title":"🤝友链"},{"content":"关于我\n英文名: Asher 职业: 程序员 运动: 跑步、乒乓球、爬山 ","permalink":"https://paper.3kis.top/about/","summary":"关于我 英文名: Asher 职业: 程序员 运动: 跑步、乒乓球、爬山","title":"🙋🏻‍♂️关于"}]